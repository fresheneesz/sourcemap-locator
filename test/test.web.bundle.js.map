{"version":3,"sources":["webpack/bootstrap 9c0f849ab33b0e7e162f","./test.web.js","../~/deadunit/~/async-future/asyncFuture.js","../~/deadunit/basicFormatter.js","../~/deadunit/~/deadunit-core/~/async-future/asyncFuture.js","../~/deadunit/~/proto/proto.js","../~/webpack/~/node-libs-browser/~/process/browser.js","../~/ajax/ajax.js","../~/ajax/~/async-future/~/trimArguments/trimArguments.js","../~/deadunit/deadunit.browser.js","../~/deadunit/deadunit.internal.js","../~/deadunit/defaultFormats.js","../~/deadunit/indent.js","../~/deadunit/~/deadunit-core/deadunitCore.browser.js","../~/deadunit/~/deadunit-core/deadunitCore.js","../~/deadunit/~/deadunit-core/~/stackinfo/exceptionMode.js","../~/deadunit/~/deadunit-core/~/stackinfo/~/stacktrace-js/stacktrace.js","../~/deadunit/~/deadunit-core/~/stackinfo/stackinfo.js","../~/deadunit/~/deadunit-core/~/stackinfo/tracelineParser.js","../~/deadunit/~/deadunit-core/processResults.js","./testResources/source.map.js ../~/raw-loader","./testResources/sourceFileAtSymbol.js ../~/raw-loader","./testResources/sourceFileHashSymbol.js ../~/raw-loader","./testResources/sourceFile_SourceMapHeader.js ../~/raw-loader","../~/webpack/~/node-libs-browser/~/path-browserify/index.js","../~/webpack/~/node-libs-browser/~/util/~/inherits/inherits_browser.js","../~/webpack/~/node-libs-browser/~/util/support/isBufferBrowser.js","../~/webpack/~/node-libs-browser/~/util/util.js","../sourcemap-locator.js","./tests.js","../~/ajax/~/async-future/asyncFuture.js"],"names":[],"mappings":";;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA,wC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvCA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAC;;;AAGD;AACA;AACA;;AAEA,MAAK;AACL;;AAEA,MAAK;AACL;;AAEA,MAAK;AACL;;AAEA,MAAK;AACL;;AAEA,MAAK;AACL;AACA;AACA,E;;;;;;;;;AChCA;;AAEA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;;AAET;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;;;AAGT,MAAK;AACL;AACA;;AAEA;AACA;;AAEA,2CAA0C,MAAM;AAChD;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,MAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,UAAS;AACT;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;AACA;;AAEA,cAAa;AACb;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,cAAa;AACb;AACA,MAAK;AACL;;;;AAIA;AACA;;AAEA;AACA,gBAAe;AACf;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;;;;;;;;;;AC5RA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;;AAEA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChGA;;AAEA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;;AAET;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;;;AAGT,MAAK;AACL;AACA;;AAEA;AACA;;AAEA,2CAA0C,MAAM;AAChD;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,4BAA2B;AAC3B;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,MAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;;;AAIA;AACA;;AAEA;AACA,gBAAe;AACf;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;;;;;;;;;;ACzQA;AACA;;AAEA,mGAAkG,iBAAiB;AACnH;AACA;;AAEA;AACA;AACA;;AAEA,MAAK,OAAO;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA,gDAA+C;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAmC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,2BAA0B;;AAE1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;AC9FA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA2B;AAC3B;AACA;AACA;;;;;;;;;;AC3DA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAsC;AACtC,2CAA0C;AAC1C;AACA;AACA;;AAEA,MAAK,OAAO;AACZ,wCAAuC,KAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAa,WAAW;AACxB;AACA;;AAEA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB;;AAEjB,sCAAqC,yCAAyC;;AAE9E,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACnGA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA4B,MAAM;AAClC;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;;;ACbA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB,kBAAiB;;AAEjB;AACA;AACA,kBAAiB;AACjB;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA,EAAC;;;;;;;;;;AC5DD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;;;;;;;;;;AChCA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,2CAA0C,aAAa;AACvD;AACA,+CAA8C,+BAA+B;AAC7E;AACA,kBAAiB;AACjB,2CAA0C,iBAAiB;AAC3D;AACA,+CAA8C,YAAY;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,sBAAqB,oBAAoB,6BAA6B;AACtE;;AAEA;AACA,0BAAyB;AACzB,0BAAyB;AACzB,sBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA6F;AAC7F,mGAAkG;AAClG,0DAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAiC;AACjC;;AAEA,cAAa;AACb;;AAEA;;AAEA;AACA;AACA,sBAAqB,oBAAoB,oBAAoB;AAC7D;;AAEA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB,sBAAqB;AACrB;;AAEA;;AAEA;AACA,mHAAkH;AAClH,+CAA8C,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM;AAC9F;AACA;AACA;AACA;AACA,8FAA6F;AAC7F;AACA;AACA;AACA,uCAAsC;AACtC;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA,mDAAkD;AAClD,UAAS;AACT;AACA;AACA;AACA;AACA,kBAAiB;AACjB;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA,kBAAiB;AACjB,6CAA4C;AAC5C,kCAAiC;AACjC,cAAa;AACb,gBAAe;AACf,oCAAmC;AACnC,kCAAiC;AACjC,cAAa;AACb;AACA,cAAa,oBAAoB;AACjC,cAAa;AACb;AACA,cAAa,kBAAkB;AAC/B,cAAa;AACb,4BAA2B;AAC3B,iCAAgC;AAChC,cAAa;AACb,+BAA8B;AAC9B,uCAAsC;AACtC,cAAa;AACb,yBAAwB;AACxB,iCAAgC;AAChC,cAAa;AACb,0BAAyB;AACzB,4BAA2B;AAC3B,oCAAmC;AACnC,cAAa;AACb,mCAAkC;AAClC,mCAAkC;AAClC,kBAAiB;AACjB,6BAA4B;AAC5B,iCAAgC;AAChC,uCAAsC;AACtC,sCAAqC;AACrC,kBAAiB;AACjB,8BAA6B;AAC7B,+BAA8B;AAC9B,cAAa;AACb,6BAA4B;AAC5B,4CAA2C,YAAY,aAAa;AACpE,cAAa;AACb,sCAAqC;AACrC,iCAAgC,WAAW,iBAAiB;AAC5D,kBAAiB;AACjB;AACA,4BAA2B;AAC3B,iCAAgC;AAChC,cAAa;AACb,4CAA2C;AAC3C,gCAA+B;AAC/B,cAAa;AACb,yBAAwB;AACxB,iCAAgC;AAChC,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC,mCAAkC;AAClC,kCAAiC;AACjC,iCAAgC;AAChC,iCAAgC;AAChC;;AAEA;AACA;AACA,mCAAkC;AAClC;AACA,oCAAmC,MAAM,MAAM,MAAM;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5dA;AACA;AACA;AACA,E;;;;;;;;;;;ACJA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA6B;;AAE7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,MAAK;;AAEL;AACA;AACA;AACA,EAAC;;;AAGD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,8CAA6C,OAAO;AACpD;AACA;AACA,kBAAiB,WAAW;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,MAAK;AACL;AACA;AACA;;AAEA;AACA,E;;;;;;;;;ACjHA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C,4BAA4B;;AAEtE;;AAEA;AACA,+CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gCAA+B,2BAA2B;AAC1D;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,sBAAqB;AACrB;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,4CAA2C;AAC3C;AACA;;AAEA,6CAA4C;AAC5C;;AAEA;AACA;AACA;AACA,sBAAqB;;AAErB;AACA;;AAEA;AACA,6CAA4C;AAC5C;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA,sBAAqB;;AAErB;;AAEA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA,sBAAqB;;AAErB;;AAEA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;;AAEb;AACA;AACA;;AAEA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;;AAEb;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA,kBAAiB;AACjB;AACA,UAAS;;AAET;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uCAAsC;AACtC;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,UAAS;AACT;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA4B,QAAQ;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;;;AC/eA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA;AACA,+BAA8B;AAC9B;AACA;AACA;AACA,+BAA8B;AAC9B;AACA;AACA,0BAAyB;AACzB,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;AACH;;AAEA;AACA,IAAG;AACH;AACA;AACA,EAAC;AACD;AACA;AACA;AACA,WAAU,MAAM;AAChB,WAAU,QAAQ;AAClB,cAAa,MAAM;AACnB;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAgB,MAAM;AACtB,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA,WAAU;AACV;AACA;AACA,OAAM;;AAEN;AACA;AACA;AACA,WAAU;AACV;AACA;AACA,OAAM;;AAEN;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,WAAU;AACV;AACA,WAAU;AACV;AACA,WAAU;AACV;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA,oCAAmC;AACnC;AACA;AACA;AACA,oCAAmC;AACnC;AACA;AACA,+BAA8B;AAC9B,WAAU;AACV;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA,OAAM;;AAEN;AACA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,OAAO;AACvB,iBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C,UAAU;AACtD,8DAA6D,UAAU;AACvE;AACA;AACA,OAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,UAAU;AAC1C;AACA,OAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA8D,UAAU;AACxE;AACA;AACA;AACA,OAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA6E,UAAU;AACvF,OAAM;;AAEN;AACA,uBAAsB,UAAU;AAChC;;AAEA,6CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,UAAU;AAChC;;AAEA,6CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAM;;AAEN;AACA;AACA;AACA;AACA,uBAAsB,UAAU;AAChC;;AAEA,6CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAM;;AAEN;AACA;AACA,uBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;;AAEN;AACA;AACA;AACA,iBAAgB,gBAAgB;AAChC,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,yBAAwB,iBAAiB;AACzC;AACA;AACA;AACA,eAAc;AACd;AACA,eAAc;AACd;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA,mBAAkB;AAClB;AACA,mBAAkB;AAClB;AACA,mBAAkB;AAClB;AACA,mBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,OAAM;;AAEN,qBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA,OAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA,eAAc;AACd;AACA,eAAc;AACd;AACA;AACA;AACA,yBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA,OAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAAyF;AACzF,OAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;;AAEN;AACA,yBAAwB,kBAAkB;AAC1C,+BAA8B,WAAW;AACzC;AACA;;AAEA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA,qDAAoD,UAAU;AAC9D;AACA;AACA;AACA;AACA;AACA,OAAM;;AAEN;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA,OAAM;;AAEN;AACA;AACA;AACA,uBAAsB,KAAK,EAAE,KAAK;AAClC;AACA,cAAa,KAAK,cAAc,KAAK;AACrC;AACA;AACA,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA,yBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAC,G;;;;;;;;;AC7cD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,2B;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAAyC,UAAU;AACnD;AACA;AACA,yD;;;;;;;;;AC7FA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA,cAAa;;AAEb;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,E;;;;;;;;;AC3HA,+C;;;;;;;;;ACAA,yCAAwC,SAAS,yD;;;;;;;;;ACAjD,yCAAwC,SAAS,yD;;;;;;;;;ACAjD,yCAAwC,SAAS,C;;;;;;;;;;;ACAjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,QAAQ;AACxC;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU,MAAM;AAChB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8BAA6B,IAAI;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qCAAoC,8BAA8B;AAClE;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU,oBAAoB;AAC9B;AACA;;AAEA;AACA,WAAU,UAAU;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAA+B,sBAAsB;AACrD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,eAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAkC;AAClC;AACA;AACA;AACA;AACA;;;;;;;;;;;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,wBAAuB,SAAS;AAChC;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA4C,KAAK;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,oCAAmC,OAAO;AAC1C;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;;AAGA;AACA;AACA,0DAAyD;AACzD;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT;AACA;AACA,YAAW;AACX;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA,YAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;ACzkBA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA,0CAAyC;AACzC;AACA;AACA;AACA,UAAS;AACT,MAAK;AACL;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,E;;;;;;;;;;ACtDA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;AACA,E;;;;;;;;;AC9DA;;AAEA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;;AAET;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;;;AAGT,MAAK;AACL;AACA;;AAEA;AACA;;AAEA,2CAA0C,MAAM;AAChD;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,MAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,UAAS;AACT;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;AACA;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA,kBAAiB;;AAEjB,cAAa;AACb;AACA;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,cAAa;AACb;AACA,MAAK;AACL;;;;AAIA;AACA;;AAEA;AACA,gBAAe;AACf;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA","sourcesContent":["\n// The module cache\nvar installedModules = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(installedModules[moduleId])\n\t\treturn installedModules[moduleId].exports;\n\t\n\t// Create a new module (and put it into the cache)\n\tvar module = installedModules[moduleId] = {\n\t\texports: {},\n\t\tid: moduleId,\n\t\tloaded: false\n\t};\n\t\n\t// Execute the module function\n\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\t\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = modules;\n\n// expose the module cache\n__webpack_require__.c = installedModules;\n\n// __webpack_public_path__\n__webpack_require__.p = \"\";\n\n\n// Load entry module and return exports\nreturn __webpack_require__(0);","var unit = require(\"deadunit/deadunit.browser\")\r\nvar getTests = require(\"./tests\")\r\n\r\nunit.test(function() {\r\n    this.count(4)\r\n\r\n    var tests = getTests(getFileContents)\r\n    for(var test in tests) {\r\n        this.test(test, tests[test])\r\n    }\r\n}).writeHtml($('body'))\r\n\r\n\r\nfunction getFileContents(path) {\r\n    if(path === \"testResources/sourceFileHashSymbol.js\") {\r\n        return require(\"raw!./testResources/sourceFileHashSymbol.js\")\r\n\r\n    } else if(path === \"testResources/sourceFileAtSymbol.js\") {\r\n        return require(\"raw!./testResources/sourceFileAtSymbol.js\")\r\n\r\n    } else if(path === \"testResources/sourceFile_SourceMapHeader.js\") {\r\n        return require(\"raw!./testResources/sourceFile_SourceMapHeader.js\")\r\n\r\n    } else if(path === \"testResources/sourceFile_X-SourceMapHeader.js\") {\r\n        return require(\"raw!./testResources/sourceFile_X-SourceMapHeader.js\")\r\n\r\n    } else if(path === \"testResources/source.map.js\") {\r\n        return require(\"raw!./testResources/source.map.js\")\r\n\r\n    } else {\r\n        throw new Error(\"Didnt expect you'd be needing \"+path)\r\n    }\r\n}","/* Copyright (c) 2013 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n\r\nvar trimArgs = require(\"trimArguments\")\r\n\r\n\r\nmodule.exports = Future\r\n\r\nFuture.debug = false // switch this to true if you want ids and long stack traces\r\n\r\nvar curId = 0         // for ids\\\r\nfunction Future(value) {\r\n\tif(arguments.length > 0) {\r\n\t\tvar f = new Future()\r\n        f.return(value)\r\n        return f\r\n\t} else {\r\n        this.isResolved = false\r\n        this.queue = []\r\n        if(Future.debug) {\r\n            curId++\r\n            this.id = curId\r\n        }\r\n    }\r\n}\r\n\r\n// static methods\r\n\r\n// has one parameter: either a bunch of futures, or a single array of futures\r\n// returns a promise that resolves when one of them errors, or when all of them succeeds\r\nFuture.all = function() {\r\n    if(arguments[0] instanceof Array) {\r\n        var futures = arguments[0]\r\n    } else {\r\n        var futures = trimArgs(arguments)\r\n    }\r\n\r\n    var f = new Future()\r\n    var results = []\r\n\r\n    if(futures.length > 0) {\r\n        var current = futures[0]\r\n        futures.forEach(function(future, index) {\r\n            current = current.then(function(v) {\r\n                results[index] = v\r\n                return futures[index+1]\r\n            })\r\n        })\r\n\r\n        //if\r\n        current.catch(function(e) {\r\n            f.throw(e)\r\n        })\r\n        // else\r\n        current.then(function() {\r\n            f.return(results)\r\n        })\r\n\r\n\r\n    } else {\r\n        f.return(results)\r\n    }\r\n\r\n    return f\r\n}\r\n\r\n// either used like futureWrap(function(){ ... })(arg1,arg2,etc) or\r\n//  futureWrap(object, 'methodName')(arg1,arg2,etc)\r\nFuture.wrap = function() {\r\n    // function\r\n    if(arguments.length === 1) {\r\n        var fn = arguments[0]\r\n        var object = undefined\r\n\r\n\r\n    // object, function\r\n    } else {\r\n        var object = arguments[0]\r\n        var fn = object[arguments[1]]\r\n    }\r\n\r\n    return function() {\r\n        var args = Array.prototype.slice.call(arguments)\r\n        var future = new Future\r\n        args.push(future.resolver())\r\n        var me = this\r\n        if(object) me = object\r\n        fn.apply(me, args)\r\n        return future\r\n    }\r\n}\r\n\r\n\r\n// default\r\nvar unhandledErrorHandler = function(e) {\r\n    setTimeout(function() {\r\n        throw e\r\n    },0)\r\n}\r\n\r\n// setup unhandled error handler\r\n// unhandled errors happen when done is called, and  then an exception is thrown from the future\r\nFuture.error = function(handler) {\r\n    unhandledErrorHandler = handler\r\n}\r\n\r\n// instance methods\r\n\r\n// returns a value for the future (can only be executed once)\r\n// if there are callbacks waiting on this value, they are run in the next tick\r\n    // (ie they aren't run immediately, allowing the current thread of execution to complete)\r\nFuture.prototype.return = function(v) {\r\n    resolve(this, 'return', v)\r\n}\r\nFuture.prototype.throw = function(e) {\r\n    resolve(this, 'error', e)\r\n}\r\n\r\nfunction setNext(that, future) {\r\n    if(future !== undefined && !isLikeAFuture(future) )\r\n        throw Error(\"Value returned from then or catch *not* a Future: \"+future)\r\n\r\n    resolve(that, 'next', future)\r\n}\r\n\r\nfunction wait(that, cb) {\r\n    if(that.isResolved) {\r\n        executeCallbacks(that, [cb])\r\n    } else {\r\n        that.queue.push(cb)\r\n    }\r\n}\r\n\r\n// duck typing to determine if something is or isn't a future\r\nfunction isLikeAFuture(x) {\r\n    return x.isResolved !== undefined && x.queue !== undefined && x.then !== undefined\r\n}\r\n\r\nfunction waitOnResult(f, result, cb) {\r\n    wait(result, function() {\r\n        if(this.hasError) {\r\n            f.throw(this.error)\r\n        } else if(this.hasNext) {\r\n            waitOnResult(f, this.next, cb)\r\n        } else {\r\n            try {\r\n                setNext(f, cb(this.result))\r\n            } catch(e) {\r\n                f.throw(e)\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\n\r\n// cb takes one parameter - the value returned\r\n// cb can return a Future, in which case the result of that Future is passed to next-in-chain\r\nFuture.prototype.then = function(cb) {\r\n    var f = new Future\r\n    wait(this, function() {\r\n        if(this.hasError)\r\n            f.throw(this.error)\r\n        else if(this.hasNext)\r\n            waitOnResult(f, this.next, cb)\r\n        else {\r\n            try {\r\n                setNext(f, cb(this.result))\r\n            } catch(e) {\r\n                f.throw(e)\r\n            }\r\n        }\r\n    })\r\n    return f\r\n}\r\n// cb takes one parameter - the error caught\r\n// cb can return a Future, in which case the result of that Future is passed to next-in-chain\r\nFuture.prototype.catch = function(cb) {\r\n    var f = new Future\r\n    wait(this, function() {\r\n        if(this.hasError) {\r\n            try {\r\n                setNext(f, cb(this.error))\r\n            } catch(e) {\r\n                f.throw(e)\r\n            }\r\n        } else if(this.hasNext) {\r\n            this.next.then(function(v) {\r\n                f.return(v)\r\n            }).catch(function(e) {\r\n                setNext(f, cb(e))\r\n            })\r\n        } else {\r\n            f.return(this.result)\r\n        }\r\n    })\r\n    return f\r\n}\r\n// cb takes no parameters\r\n// callback's return value is ignored, but thrown exceptions propogate normally\r\nFuture.prototype.finally = function(cb) {\r\n    var f = new Future\r\n    wait(this, function() {\r\n        try {\r\n            if(this.hasNext) {\r\n                this.next.then(function(v) {\r\n                    cb()\r\n                    f.return(v)\r\n                }).catch(function(e) {\r\n                    cb()\r\n                    f.throw(e)\r\n                })\r\n            } else if(this.hasError) {\r\n                cb()\r\n                f.throw(this.error)\r\n\r\n            } else  {\r\n                cb()\r\n                f.return(this.result)\r\n            }\r\n        } catch(e) {\r\n            f.throw(e)\r\n        }\r\n    })\r\n    return f\r\n}\r\n\r\n// all unused futures should end with this (e.g. most then-chains)\r\n// detatches the future so any propogated exception is thrown (so the exception isn't silently lost)\r\nFuture.prototype.done = function() {\r\n    wait(this, function() {\r\n        if(this.hasError) {\r\n            unhandledErrorHandler(this.error)\r\n        } else if(this.hasNext) {\r\n            this.next.catch(function(e) {\r\n                unhandledErrorHandler(e)\r\n            })\r\n        }\r\n    })\r\n}\r\n\r\n\r\n\r\nFuture.prototype.resolver = function() {\r\n    var me = this\r\n\r\n    return function(e,v) {\r\n        if(e) { // error argument\r\n            me.throw(e)\r\n        } else {\r\n            me.return(v)\r\n        }\r\n    }\r\n}\r\n\r\nFuture.prototype.resolved = function() {\r\n    return this.isResolved\r\n}\r\n\r\n\r\nfunction resolve(that, type, value) {\r\n    if(that.isResolved)\r\n        throw Error(\"Future resolved more than once! Resolution: \"+value)\r\n\r\n    that.isResolved = true\r\n    that.hasError = type === 'error'\r\n    that.hasNext = type === 'next' && value !== undefined\r\n\r\n    if(that.hasError)\r\n        that.error = value\r\n    else if(that.hasNext)\r\n        that.next = value\r\n    else\r\n        that.result = value\r\n\r\n    executeCallbacks(that, that.queue)\r\n}\r\n\r\nfunction executeCallbacks(that, callbacks) {\r\n    if(callbacks.length > 0) {\r\n        setTimeout(function() {\r\n            callbacks.forEach(function(cb) {\r\n                cb.apply(that)\r\n            })\r\n        },0)\r\n    }\r\n}\r\n","var Future = require('async-future')\r\n\r\n// built in test formatting helper\r\nmodule.exports = function(unitTest, printOnTheFly/*, [printLateEvents,] format*/) {\r\n    if(arguments.length === 4) {\r\n        var format = arguments[3]\r\n        var printLateEvents = true\r\n    } else /* if(arguments.length > 4) */{\r\n        var printLateEvents = arguments[3]\r\n        var format = arguments[4]\r\n    }\r\n\r\n    var result = new Future\r\n\r\n    var events = {\r\n        end: function(e) {\r\n            var results = unitTest.results(printLateEvents)\r\n            result.return(formatGroup(results, format, 0).result)\r\n        }\r\n    }\r\n\r\n    if(printOnTheFly) {\r\n        events.assert = function(e) {\r\n            console.log(format.assert(e))\r\n        }\r\n        events.exception = function(e) {\r\n            console.log(format.exception(e.error))\r\n        }\r\n        events.log = function(e) {\r\n            console.log(format.log(e.values))\r\n        }\r\n    }\r\n\r\n    unitTest.events(events)\r\n\r\n    return result\r\n}\r\n\r\nfunction formatGroup(testResults, format, nestingLevel) {\r\n    var assertSuccesses = 0\r\n    var assertFailures = 0\r\n    var exceptions = 0\r\n\r\n    var testCaseSuccesses= 0, testCaseFailures=0;\r\n\r\n    var results = []\r\n    testResults.results.forEach(function(result) {\r\n        if(result.type === 'assert') {\r\n            if(result.success) {\r\n                testCaseSuccesses++\r\n                assertSuccesses ++\r\n            } else {\r\n                testCaseFailures++\r\n                assertFailures++\r\n            }\r\n\r\n            results.push(format.assert(result, testResults.name))\r\n\r\n        } else if(result.type === 'group') {\r\n            var group = formatGroup(result, format, nestingLevel+1)\r\n            exceptions+= group.exceptions\r\n\r\n            if(group.failures === 0 && group.exceptions === 0)\r\n                testCaseSuccesses++\r\n            else\r\n                testCaseFailures++\r\n\r\n            results.push(group.result)\r\n            assertSuccesses+= group.assertSuccesses\r\n            assertFailures+= group.assertFailures\r\n\r\n        } else if(result.type === 'log') {\r\n            results.push(format.log(result.values))\r\n        } else {\r\n            throw new Error(\"Unknown result type: \"+result.type)\r\n        }\r\n    })\r\n\r\n    var exceptionResults = []\r\n    testResults.exceptions.forEach(function(e) {\r\n        exceptionResults.push(format.exception(e))\r\n    })\r\n\r\n    exceptions+= testResults.exceptions.length\r\n\r\n    var formattedGroup = format.group(testResults.name, testResults.duration,\r\n                                      testCaseSuccesses, testCaseFailures,\r\n                                      assertSuccesses, assertFailures, exceptions,\r\n                                      results, exceptionResults, nestingLevel, testResults.timeout)\r\n    return {result: formattedGroup,\r\n            successes: testCaseSuccesses,\r\n            failures: testCaseFailures,\r\n            assertSuccesses: assertSuccesses,\r\n            assertFailures: assertFailures,\r\n            exceptions: exceptions\r\n    }\r\n}\r\n\r\n","/* Copyright (c) 2013 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n\r\nvar trimArgs = require(\"trimArguments\")\r\n\r\n\r\nmodule.exports = Future\r\n\r\nFuture.debug = false // switch this to true if you want ids and long stack traces\r\n\r\nvar curId = 0         // for ids\\\r\nfunction Future(value) {\r\n\tif(arguments.length > 0) {\r\n\t\tvar f = new Future()\r\n        f.return(value)\r\n        return f\r\n\t} else {\r\n        this.isResolved = false\r\n        this.queue = []\r\n        if(Future.debug) {\r\n            curId++\r\n            this.id = curId\r\n        }\r\n    }\r\n}\r\n\r\n// static methods\r\n\r\n// has one parameter: either a bunch of futures, or a single array of futures\r\n// returns a promise that resolves when one of them errors, or when all of them succeeds\r\nFuture.all = function() {\r\n    if(arguments[0] instanceof Array) {\r\n        var futures = arguments[0]\r\n    } else {\r\n        var futures = trimArgs(arguments)\r\n    }\r\n\r\n    var f = new Future()\r\n    var results = []\r\n\r\n    if(futures.length > 0) {\r\n        var current = futures[0]\r\n        futures.forEach(function(future, index) {\r\n            current = current.then(function(v) {\r\n                results[index] = v\r\n                return futures[index+1]\r\n            })\r\n        })\r\n\r\n        //if\r\n        current.catch(function(e) {\r\n            f.throw(e)\r\n        })\r\n        // else\r\n        current.then(function() {\r\n            f.return(results)\r\n        })\r\n\r\n\r\n    } else {\r\n        f.return(results)\r\n    }\r\n\r\n    return f\r\n}\r\n\r\n// either used like futureWrap(function(){ ... })(arg1,arg2,etc) or\r\n//  futureWrap(object, 'methodName')(arg1,arg2,etc)\r\nFuture.wrap = function() {\r\n    // function\r\n    if(arguments.length === 1) {\r\n        var fn = arguments[0]\r\n        var object = undefined\r\n\r\n\r\n    // object, function\r\n    } else {\r\n        var object = arguments[0]\r\n        var fn = object[arguments[1]]\r\n    }\r\n\r\n    return function() {\r\n        var args = Array.prototype.slice.call(arguments)\r\n        var future = new Future\r\n        args.push(future.resolver())\r\n        var me = this\r\n        if(object) me = object\r\n        fn.apply(me, args)\r\n        return future\r\n    }\r\n}\r\n\r\n\r\n// default\r\nvar unhandledErrorHandler = function(e) {\r\n    setTimeout(function() { //  nextTick\r\n        throw e\r\n    },0)\r\n}\r\n\r\n// setup unhandled error handler\r\n// unhandled errors happen when done is called, and  then an exception is thrown from the future\r\nFuture.error = function(handler) {\r\n    unhandledErrorHandler = handler\r\n}\r\n\r\n// instance methods\r\n\r\n// returns a value for the future (can only be executed once)\r\n// if there are callbacks waiting on this value, they are run in the next tick\r\n    // (ie they aren't run immediately, allowing the current thread of execution to complete)\r\nFuture.prototype.return = function(v) {\r\n    resolve(this, 'return', v)\r\n}\r\nFuture.prototype.throw = function(e) {\r\n    resolve(this, 'error', e)\r\n}\r\n\r\nfunction setNext(that, future) {\r\n    if(future !== undefined && !isLikeAFuture(future) )\r\n        throw Error(\"Value returned from then or catch *not* a Future: \"+future)\r\n\r\n    resolve(that, 'next', future)\r\n}\r\n\r\nfunction wait(that, cb) {\r\n    if(that.isResolved) {\r\n        executeCallbacks(that, [cb])\r\n    } else {\r\n        that.queue.push(cb)\r\n    }\r\n}\r\n\r\n// duck typing to determine if something is or isn't a future\r\nfunction isLikeAFuture(x) {\r\n    return x.isResolved !== undefined && x.queue !== undefined && x.then !== undefined\r\n}\r\n\r\nfunction waitOnResult(f, result, cb) {\r\n    wait(result, function() {\r\n        if(this.hasError) {\r\n            f.throw(this.error)\r\n        } else if(this.hasNext) {\r\n            waitOnResult(f, this.next, cb)\r\n        } else {\r\n            try {\r\n                setNext(f, cb(this.result))\r\n            } catch(e) {\r\n                f.throw(e)\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\n\r\n// cb takes one parameter - the value returned\r\n// cb can return a Future, in which case the result of that Future is passed to next-in-chain\r\nFuture.prototype.then = function(cb) {\r\n    var f = new Future\r\n    wait(this, function() {\r\n        if(this.hasError)\r\n            f.throw(this.error)\r\n        else if(this.hasNext)\r\n            waitOnResult(f, this.next, cb)\r\n        else {\r\n            try {\r\n                setNext(f, cb(this.result))\r\n            } catch(e) {\r\n                f.throw(e)\r\n            }\r\n        }\r\n    })\r\n    return f\r\n}\r\n// cb takes one parameter - the error caught\r\n// cb can return a Future, in which case the result of that Future is passed to next-in-chain\r\nFuture.prototype.catch = function(cb) {\r\n    var f = new Future\r\n    wait(this, function() {\r\n        if(this.hasError) {\r\n            try {\r\n                setNext(f, cb(this.error))\r\n            } catch(e) {\r\n                f.throw(e)\r\n            }\r\n        } else if(this.hasNext)\r\n            setNext(f, this.next)\r\n        else\r\n            f.return(this.result)\r\n    })\r\n    return f\r\n}\r\n// cb takes no parameters\r\n// callback's return value is ignored, but thrown exceptions propogate normally\r\nFuture.prototype.finally = function(cb) {\r\n    var f = new Future\r\n    wait(this, function() {\r\n        try {\r\n            cb()\r\n            if(this.hasError)\r\n                f.throw(this.error)\r\n            else {\r\n                f.return(this.result)\r\n            }\r\n        } catch(e) {\r\n            f.throw(e)\r\n        }\r\n    })\r\n    return f\r\n}\r\n\r\n// all unused futures should end with this (e.g. most then-chains)\r\n// detatches the future so any propogated exception is thrown (so the exception isn't silently lost)\r\nFuture.prototype.done = function() {\r\n    wait(this, function() {\r\n        if(this.hasError) {\r\n            unhandledErrorHandler(this.error)\r\n        }\r\n    })\r\n}\r\n\r\n\r\n\r\nFuture.prototype.resolver = function() {\r\n    var me = this\r\n\r\n    return function(e,v) {\r\n        if(e) { // error argument\r\n            me.throw(e)\r\n        } else {\r\n            me.return(v)\r\n        }\r\n    }\r\n}\r\n\r\nFuture.prototype.resolved = function() {\r\n    return this.isResolved\r\n}\r\n\r\n\r\nfunction resolve(that, type, value) {\r\n    if(that.isResolved)\r\n        throw Error(\"Future resolved more than once! Resolution: \"+value)\r\n\r\n    that.isResolved = true\r\n    that.hasError = type === 'error'\r\n    that.hasNext = type === 'next' && value !== undefined\r\n\r\n    if(that.hasError)\r\n        that.error = value\r\n    else if(that.hasNext)\r\n        that.next = value\r\n    else\r\n        that.result = value\r\n\r\n    executeCallbacks(that, that.queue)\r\n}\r\n\r\nfunction executeCallbacks(that, callbacks) {\r\n    if(callbacks.length > 0) {\r\n        setTimeout(function() {\r\n            callbacks.forEach(function(cb) {\r\n                cb.apply(that)\r\n            })\r\n        },0)\r\n    }\r\n}\r\n","\"use strict\";\r\n/* Copyright (c) 2013 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n\r\nvar prototypeName='prototype', undefined, protoUndefined='undefined', init='init', ownProperty=({}).hasOwnProperty; // minifiable variables\r\nfunction proto() {\r\n    var args = arguments // minifiable variables\r\n\r\n    if(args.length == 1) {\r\n        var parent = {}\r\n        var prototypeBuilder = args[0]\r\n\r\n    } else { // length == 2\r\n        var parent = args[0]\r\n        var prototypeBuilder = args[1]\r\n    }\r\n\r\n    // special handling for Error objects\r\n    var namePointer = {}\r\n    if([Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError].indexOf(parent) !== -1) {\r\n        parent = normalizeErrorObject(parent, namePointer)\r\n    }\r\n\r\n    // set up the parent into the prototype chain if a parent is passed\r\n    var parentIsFunction = typeof(parent) === \"function\"\r\n    if(parentIsFunction) {\r\n        prototypeBuilder[prototypeName] = parent[prototypeName]\r\n    } else {\r\n        prototypeBuilder[prototypeName] = parent\r\n    }\r\n\r\n    // the prototype that will be used to make instances\r\n    var prototype = new prototypeBuilder(parent)\r\n    prototype.constructor = ProtoObjectFactory;    // set the constructor property on the prototype\r\n    namePointer.name = prototype.name\r\n\r\n    // if there's no init, assume its inheriting a non-proto class, so default to applying the superclass's constructor.\r\n    if(!prototype[init] && parentIsFunction) {\r\n        prototype[init] = function() {\r\n            parent.apply(this, arguments)\r\n        }\r\n    }\r\n\r\n    // constructor for empty object which will be populated via the constructor\r\n    var F = function() {}\r\n        F[prototypeName] = prototype    // set the prototype for created instances\r\n\r\n    function ProtoObjectFactory() {     // result object factory\r\n        var x = new F()                 // empty object\r\n\r\n        if(prototype[init]) {\r\n            var result = prototype[init].apply(x, arguments)    // populate object via the constructor\r\n            if(result === proto[protoUndefined])\r\n                return undefined\r\n            else if(result !== undefined)\r\n                return result\r\n            else\r\n                return x\r\n        } else {\r\n            return x\r\n        }\r\n    }\r\n\r\n    // add all the prototype properties onto the static class as well (so you can access that class when you want to reference superclass properties)\r\n    for(var n in prototype) {\r\n        try {\r\n            ProtoObjectFactory[n] = prototype[n]\r\n        } catch(e) {\r\n            // do nothing, if a property (like `name`) can't be set, just ignore it\r\n        }\r\n    }\r\n\r\n    ProtoObjectFactory[prototypeName] = prototype  // set the prototype on the object factory\r\n\r\n    return ProtoObjectFactory;\r\n}\r\n\r\nproto[protoUndefined] = {} // a special marker for when you want to return undefined from a constructor\r\n\r\nmodule.exports = proto\r\n\r\nfunction normalizeErrorObject(ErrorObject, namePointer) {\r\n    function NormalizedError() {\r\n        var tmp = new ErrorObject(arguments[0])\r\n        tmp.name = namePointer.name\r\n\r\n        this.stack = tmp.stack\r\n        this.message = tmp.message\r\n\r\n        return this\r\n    }\r\n        var IntermediateInheritor = function() {}\r\n            IntermediateInheritor.prototype = ErrorObject.prototype\r\n        NormalizedError.prototype = new IntermediateInheritor()\r\n    return NormalizedError\r\n}","// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n","var Future = require(\"async-future\")\n\n// returns the XHR function or equivalent for use with ajax\n// memoizes the function for faster repeated use\nvar createXMLHTTPObject = function() {\n    var versions = [\"Msxml2.XMLHTTP\",\n                    \"Msxml3.XMLHTTP\",\n                    \"Microsoft.XMLHTTP\",\n                    \"MSXML2.XmlHttp.6.0\",\n                    \"MSXML2.XmlHttp.5.0\",\n                    \"MSXML2.XmlHttp.4.0\",\n                    \"MSXML2.XmlHttp.3.0\",\n                    \"MSXML2.XmlHttp.2.0\"\n    ]\n\n    if(XMLHttpRequest !== undefined) {  // For non-IE browsers\n        createXMLHTTPObject = function() {  // Use memoization to cache the factory\n            return new XMLHttpRequest()\n        }\n        return createXMLHTTPObject()\n\n    } else { // IE\n        for(var i=0, n=versions.length; i<n; i++) {\n            try {\n                var version = versions[i]\n                var fn = function() {\n                    return new ActiveXObject(version)\n                }\n                createXMLHTTPObject = fn   // Use memoization to cache the factory\n                return createXMLHTTPObject()\n\n            } catch(e) {   }\n        }\n    }\n\n    throw new Error('Cant get XmlHttpRequest object')\n}\n\n\n\nvar HEADER = \"([^\\\\s]+): (.*)\"\n\n// returns the contents and headers from a given URL\nexports = module.exports = function(url) {\n    if(getFromCache(url))\n        return getFromCache(url)\n\n    var futureResult = new Future\n    setOnCache(url, futureResult)\n\n    var req = createXMLHTTPObject()\n    req.onreadystatechange = function() {\n        if( req.readyState === 4 ) {\n            if( req.status === 200 ) {\n                var headers = {}\n                req.getAllResponseHeaders().split('\\n').forEach(function(line) {\n                    var match = line.match(HEADER)\n                    if(match !== null) {\n                        var name = match[1]\n                        var value = match[2]\n\n                        headers[name] = value\n                    }\n                })\n\n                futureResult.return({text: req.responseText, headers: headers})\n\n            } else {\n                var error = new Error('Error in request: Status '+req.status)\n                error.status = req.status\n                futureResult.throw(error)\n            }\n        }\n    }\n\n    req.onerror = function(e) {\n        futureResult.throw(e)\n    }\n\n\n    req.open('GET', url, true)\n    req.send()\n\n    return futureResult\n}\n\nvar cache = {}\nvar getFromCache = function(url) {\n    return cache[url]\n}\nvar setOnCache = function(url, futureResponse) {\n    cache[url] = futureResponse\n}\n\nexports.cacheGet = function(fn) {\n    getFromCache = fn\n}\nexports.cacheSet = function(fn) {\n    setOnCache = fn\n}","// resolves varargs variable into more usable form\n// args - should be a function arguments variable\n// returns a javascript Array object of arguments that doesn't count trailing undefined values in the length\nmodule.exports = function(theArguments) {\n    var args = Array.prototype.slice.call(theArguments, 0)\n\n    var count = 0;\n    for(var n=args.length-1; n>=0; n--) {\n        if(args[n] === undefined)\n            count++\n    }\n    args.splice(-0, count)\n    return args\n}","\"use strict\";\r\n/* Copyright (c) 2014 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n\r\nvar deadunitInternal = require(\"./deadunit.internal\")\r\nvar Future = require('async-future')\r\n\r\nmodule.exports = deadunitInternal({\r\n    deadunitCore: require('deadunit-core/deadunitCore.browser'),\r\n\r\n    environmentSpecificMethods: function() {\r\n        var red = 'rgb(200,30,30)'\r\n\r\n        var warningWritten = false\r\n        function warnAboutLateEvents(jqueryElement) {\r\n            if(!warningWritten) {\r\n                jqueryElement.append(\r\n                    '<div style=\"color:'+red+'\">Test results were accessed before asynchronous parts of tests were fully complete.</div>'\r\n                )\r\n                warningWritten = true\r\n            }\r\n        }\r\n\r\n        function writeLateEvent(written, ended, jqueryElement, event, manager) {\r\n            if(ended) {\r\n                written.then(function() {\r\n                    warnAboutLateEvents(jqueryElement)\r\n                    jqueryElement.append(\r\n                        '<div style=\"color:'+red+'\">'+JSON.stringify(event)+'</div>'\r\n                    )\r\n                })\r\n            }\r\n        }\r\n\r\n        // writes html on the current (browser) page\r\n        this.writeHtml = function(jqueryElement) {\r\n            var f = new Future, test = this, ended = false, written = new Future\r\n            test.events({\r\n                end: function() {\r\n                    ended = true\r\n                    test.html(false).then(function(output) {\r\n                        jqueryElement.append(output)\r\n                        written.return()\r\n                        f.return()\r\n                    })\r\n                },\r\n\r\n                assert: function(event) {\r\n                    writeLateEvent(written, ended, jqueryElement, event, test.manager)\r\n                },\r\n                exception: function(event) {\r\n                    writeLateEvent(written, ended, jqueryElement, event, test.manager)\r\n                },\r\n                log: function(event) {\r\n                    writeLateEvent(written, ended, jqueryElement, event, test.manager, event.parent, event.time)\r\n                }\r\n            })\r\n            return f\r\n        }\r\n\r\n    }\r\n})\r\n","\"use strict\";\n/* Copyright (c) 2013 Billy Tetrud - Free to use for any purpose: MIT License*/\n\nmodule.exports = function(options) {\n    var exports = {}\n\n    var deadunitCore = options.deadunitCore\n    var proto = require('proto')\n\n    var defaultFormats = require('./defaultFormats')\n    exports.format = require('./basicFormatter')\n\n    exports.error = deadunitCore.error\n\n    exports.test = proto(deadunitCore.test, function() {\n        this.string = function() {\n            return defaultFormats.text(this, undefined, /*printOnTheFly=*/false, /*printLateEvents=*/false)\n        }\n\n        this.html = function() {\n            return defaultFormats.html(this, false)\n        }\n\n        this.results = function() {\n            arguments[0] = false\n            return deadunitCore.test.results.apply(this, arguments)\n        }\n\n        options.environmentSpecificMethods.call(this)\n    })\n\n    return exports\n}\n\n","var util = require(\"util\")\r\n\r\nvar Future = require('async-future')\r\n\r\nvar formatBasic = require(\"./basicFormatter\")\r\nvar indent = require(\"./indent\")\r\n\r\n// unitTest is a deadunit-core UnitTest object\r\n// if consoleColoring is true, the string will contain console color annotations\r\n// if printOnTheFly is true, test results will be printed to the screen in addition to being returned\r\n// returns a future containing a string with the final results\r\nexports.text = function textOutput(unitTest, consoleColors, printOnTheFly, printLateEvents) {\r\n    if(printLateEvents === undefined) printLateEvents = true\r\n\r\n    function color(theColor, theString) {\r\n        if(consoleColors !== undefined)\r\n            return consoleColors[theColor](theString.toString())\r\n        else\r\n            return theString.toString()\r\n    }\r\n\r\n    var ended = false\r\n    return formatBasic(unitTest, printOnTheFly, printLateEvents, {\r\n        group: function(name, totalDuration, testSuccesses, testFailures,\r\n                              assertSuccesses, assertFailures, exceptions,\r\n                              testResults, exceptionResults, nestingLevel, timedOut) {\r\n\r\n            var total = testSuccesses+testFailures\r\n\r\n            var addResults = function() {\r\n                var result = ''\r\n                if(testResults.length > 0)\r\n                    result += '\\n'+indent('   ', testResults.join('\\n'))\r\n                if(exceptionResults.length > 0)\r\n                    result += '\\n'+indent('   ', exceptionResults.join('\\n'))\r\n                return result\r\n            }\r\n\r\n\r\n            var testColor, exceptionColor, finalColor\r\n            testColor = exceptionColor = finalColor = 'green'\r\n            if(testFailures > 0) {\r\n                testColor = finalColor = 'red'\r\n            }\r\n            if(exceptions > 0) {\r\n                exceptionColor = finalColor = 'red'\r\n            }\r\n\r\n            var durationText = timeText(totalDuration)\r\n\r\n            if(nestingLevel === 0) {\r\n                var resultsLine = ''\r\n\r\n                if(name) resultsLine += color('cyan', name+' - ')\r\n\r\n\r\n\r\n                resultsLine += color(finalColor, testSuccesses+'/'+(testSuccesses+testFailures)+' successful tests. ')+\r\n                        color('green', assertSuccesses+' pass'+plural(assertSuccesses,\"es\",\"\"))+\r\n                        ', '+color('red', assertFailures+' fail'+plural(assertFailures))+\r\n                        ', and '+color('magenta', exceptions+' exception'+plural(exceptions))+\".\"\r\n                        +color('grey', \" Took \"+durationText+\".\")\r\n\r\n                var result = ''\r\n                if(name) result += color('cyan', name)+'\\n'\r\n                result += addResults()\r\n                result += '\\n\\n'+resultsLine\r\n\r\n                if(timedOut) {\r\n                    result += color('red', '\\n    The test timed out')\r\n                }\r\n            } else {\r\n                if(!name) name = \"<unnamed test>\"\r\n                var result = color(finalColor, name)+':           '\r\n                                +color(testColor, testSuccesses+'/'+total)\r\n                                +\" and \"+color(exceptionColor, exceptionResults.length+\" exception\"+plural(exceptionResults.length))\r\n                                +color('grey', \" took \"+durationText)\r\n                result += addResults()\r\n            }\r\n\r\n            return lateEventsWarning()+result\r\n        },\r\n        assert: function(result, test) {\r\n            if(result.success) {\r\n                var word = \"Ok!  \";\r\n                var c = 'green'\r\n            } else {\r\n                var word = \"Fail:\";\r\n                var c = 'red'\r\n            }\r\n\r\n            var linesDisplay = result.sourceLines\r\n            if(result.sourceLines.indexOf(\"\\n\") !== -1) {\r\n                linesDisplay = \"\\n\"+linesDisplay;\r\n            }\r\n\r\n            var expectations = \"\"\r\n            if(!result.success && (result.actual !== undefined || result.expected !== undefined)) {\r\n                var things = []\r\n                if(result.expected !== undefined)\r\n                    things.push(\"Expected \"+valueToMessage(result.expected))\r\n                if(result.actual !== undefined)\r\n                    things.push(\"Got \"+valueToMessage(result.actual))\r\n\r\n                expectations = \" - \"+things.join(', ')\r\n            }\r\n\r\n            var column = ''\r\n            if(result.column !== undefined) {\r\n                column = color('grey', \":\"+result.column)\r\n            }\r\n\r\n            return lateEventsWarning()+color(c, word)+\" [\"+color('grey', result.file)+\" \"+result.line+column+\"] \"\r\n                        +color(c, linesDisplay)\r\n                        +expectations\r\n        },\r\n        exception: function(e) {\r\n            return lateEventsWarning()+color('red', 'Exception: ')\r\n                        +color('magenta', valueToString(e))\r\n        },\r\n        log: function(values) {\r\n            return lateEventsWarning()+values.map(function(v) {\r\n                return valueToString(v)\r\n            }).join(', ')\r\n        },\r\n        end: function() {\r\n            ended = true\r\n        }\r\n    })\r\n\r\n    var warningHasBeenPrinted = false\r\n    function lateEventsWarning() {\r\n        if(ended && !warningHasBeenPrinted && !printLateEvents) {\r\n            return color('red',\r\n                'Test results were accessed before asynchronous parts of tests were fully complete'\r\n                +\" If you have tests with asynchronous parts, make sure to use `this.count` to declare how many assertions you're waiting for.\"\r\n            )+'\\n\\n'\r\n\r\n            warningHasBeenPrinted = true\r\n        } else {\r\n            return ''\r\n        }\r\n    }\r\n}\r\n\r\nfunction valueToMessage(value) {\r\n    if(value instanceof Error) {\r\n        return value.stack\r\n    } else {\r\n        return util.inspect(value)\r\n    }\r\n}\r\n\r\nfunction valueToString(v) {\r\n    if(v instanceof Error) {\r\n        var otherProperties = []\r\n        for(var n in v) {\r\n            if(Object.hasOwnProperty.call(v, n) && n !== 'message' && n !== 'stack') {\r\n                otherProperties.push(valueToString(v[n]))\r\n            }\r\n        }\r\n\r\n        if(otherProperties.length > 0)\r\n            return v.stack +'\\n'+otherProperties.join(\"\\n\")\r\n        else\r\n            return v.stack\r\n\r\n    } else if(typeof(v) === 'string') {\r\n        return v\r\n    } else {\r\n        return util.inspect(v)\r\n    }\r\n}\r\n\r\nexports.html = function(unitTest, printLateEvents) {\r\n    if(printLateEvents === undefined) printLateEvents = true\r\n\r\n    var getTestDisplayer = function() {\r\n        return {\r\n            onToggle: function(displayNone, $bgcolor, innerSelector, outerSelector) {\r\n                if(displayNone == true) {\r\n                    $(innerSelector).css({\"display\":\"\"});\r\n                    if(outerSelector != undefined) {\r\n                        $(outerSelector).css({\"border\":\"1px solid \"+$bgcolor});\r\n                    }\r\n                } else {\r\n                    $(innerSelector).css({\"display\":\"none\"});\r\n                    if(outerSelector != undefined) {\r\n                        $(outerSelector).css({\"border\":\"\"});\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    var red = 'rgb(200,30,30)'\r\n    var darkRed = 'rgb(90,0,0)'\r\n    var lightRed = 'rgb(255,210,230)'\r\n    var black = 'rgb(20,20,20)'\r\n    var white = 'rgb(240,220,220)'\r\n    var green = 'rgb(0,100,20)'\r\n    var brightGreen = 'rgb(0,200,50)'\r\n    var purple = 'rgb(190,0,160)'\r\n    var brightPurple = 'rgb(255,126,255)'\r\n    var blue = 'rgb(0, 158, 173)'\r\n    var brightBlue = 'rgb(0, 233, 255)'\r\n    var gray = 'rgb(185, 180, 180)'\r\n\r\n\r\n    var formattedTestHtml = formatBasic(unitTest, false, 0, printLateEvents, {\r\n        group: function(name, totalDuration, testSuccesses, testFailures,\r\n                          assertSuccesses, assertFailures, exceptions,\r\n                          testResults, exceptionResults, nestingLevel, timedOut) {\r\n\r\n            var total = testSuccesses+testFailures\r\n            var mainId = getMainId(name)\r\n\r\n            if(testFailures > 0 || exceptions > 0) {\r\n                var bgcolor=red;\r\n                var show = \"true\";\r\n                var foregroundColor = lightRed\r\n            } else {\r\n                var bgcolor=green;\r\n                var show = \"false\";\r\n                var foregroundColor = brightGreen\r\n            }\r\n\r\n            var durationText = timeText(totalDuration)\r\n\r\n            if(nestingLevel === 0) {\r\n\r\n                var initTestGroup = function(mainId, bgcolor, show) {\r\n                    $(function()\r\n                    {\t$('#'+mainId).css({\"border-color\":\"'+bgcolor+'\"});\r\n                        TestDisplayer.onToggle(show, bgcolor, '#'+mainId);\r\n\r\n                        $('#'+mainId+'_final').click(function()\r\n                        {\tTestDisplayer.onToggle($('#'+mainId).css(\"display\") == \"none\", bgcolor, '#'+mainId);\r\n                        });\r\n                    });\r\n                }\r\n\r\n                var nameLine = \"\", titleLine = ''\r\n                if(name) {\r\n                    titleLine = '<h1 class=\"primaryTitle\">'+name+'</h1>'\r\n                    nameLine = name+' - '\r\n                }\r\n\r\n                var timeoutNote = \"\"\r\n                if(timedOut) {\r\n                    timeoutNote = 'The test timed out'\r\n                }\r\n\r\n                return titleLine+\r\n                       '<div class=\"testResultsArea\" id=\"'+mainId+'\">'+\r\n                            testResults.join('\\n')+\r\n                            exceptionResults.join('\\n')+\"\\n\"+\r\n                            '<div style=\"color:'+red+'\">'+timeoutNote+'</div>'+\r\n                       '</div>'+\r\n                       '<div class=\"testResultsBar link\" style=\"border:2px solid '+bgcolor+';\" id=\"'+mainId+'_final\">'+\r\n                            '<div class=\"testResultsBarInner\" style=\"background-color:'+bgcolor+';\">'+\r\n                                '<div style=\"float:right;\"><i>click on this bar</i></div>'+\r\n                                '<div><span class=\"testResultsName\">'+nameLine+'</span>' + testSuccesses+'/'+total+' successful tests. '+\r\n                                '<span style=\"color:'+brightGreen+'\">'+assertSuccesses+' pass'+plural(assertSuccesses,\"es\",\"\")+'</span>'+\r\n                                ', <span style=\"color:'+darkRed+'\">'+assertFailures+' fail'+plural(assertFailures)+'</span>'+\r\n                                ', and <span style=\"color:'+brightPurple+'\">'+exceptions+' exception'+plural(exceptions)+'</span>'+\r\n                                '. <span style=\"color: '+white+'\">Took '+durationText+\".</span>\"+\r\n                            '</div>'+\r\n                       '</div>'+\r\n\r\n                       '<script>;('+initTestGroup+')(\"'+mainId+'\", \"'+bgcolor+'\", '+show+')</script>'+\r\n                       '</div>'\r\n\r\n            } else {\r\n                var n = getNewNumber()\r\n\r\n                var testId = mainId+n\r\n\r\n                var initTest = function(mainId, bgcolor, show, n) {\r\n                    $(function()\r\n                    {\t$('#'+mainId).css({borderColor:bgcolor});\r\n                        TestDisplayer.onToggle(show, bgcolor, '#'+mainId+n+'_inner', '#'+mainId+n);\r\n\r\n                        $('.'+mainId+n+'_status').click(function()\r\n                        {\tTestDisplayer.onToggle\r\n                            (\t$('#'+mainId+n+'_inner').css(\"display\") == \"none\",\r\n                                bgcolor,\r\n                                '#'+mainId+n+'_inner',\r\n                                '#'+mainId+n+''\r\n                            );\r\n                        });\r\n                    });\r\n                }\r\n\r\n                if(!name) name = \"<unnamed test>\"\r\n\r\n                return '<div class=\"resultsArea\" id=\"'+mainId+n+'\">'+\r\n                            '<div class=\"resultsBar link '+mainId+n+'_status\" style=\"background-color:'+bgcolor+';color:'+foregroundColor+'\">'+\r\n                                name+': &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'+\r\n                                testSuccesses+'/'+total+\" and \"+exceptions+\" exception\"+plural(exceptions)\r\n                                +' <span style=\"color: white\">took '+durationText+'</span>'+\r\n                            '</div>'+\r\n                            '<div class=\"resultsAreaInner\" id=\"'+testId+'_inner\">'+\r\n                                '<h2 class=\"'+testId+'_status link\" style=\"color:'+bgcolor+';\">'+name+'</h2>'+\r\n                                testResults.join('\\n')+\"\\n\"+\r\n                                exceptionResults.join('\\n')+\"\\n\"+\r\n                            '</div>'+\r\n                            '<script>;('+initTest+')(\"'+mainId+'\", \"'+bgcolor+'\", '+show+', '+n+')</script>'+\r\n                      '</div>';\r\n            }\r\n        },\r\n        assert: function(result) {\r\n            if(false === result.success) {\r\n                var color = red;\r\n                var word = \"Fail:\";\r\n            } else {\r\n                var color = green;\r\n                var word = \"Ok!\";\r\n            }\r\n\r\n            var linesDisplay = \"<i>\"+textToHtml(result.sourceLines)+\"</i>\";\r\n            if(result.sourceLines.indexOf(\"\\n\") !== -1) {\r\n                linesDisplay = \"<br>\\n\"+linesDisplay;\r\n            }\r\n\r\n            var expectations = \"\"\r\n            if(!result.success && (result.actual !== undefined || result.expected !== undefined)) {\r\n                var things = []\r\n                if(result.expected !== undefined)\r\n                    things.push(\"Expected \"+textToHtml(valueToMessage(result.expected)))\r\n                if(result.actual !== undefined)\r\n                    things.push(\"Got \"+textToHtml(valueToMessage(result.actual)))\r\n\r\n                expectations = \" - \"+things.join(', ')\r\n            }\r\n\r\n            var column = ''\r\n            if(result.column !== undefined) {\r\n                column = \":\"+result.column\r\n            }\r\n\r\n            return '<div style=\"color:'+color+';\"><span >'+word+'</span>'+\r\n                        \" <span class='locationOuter'>[<span class='locationInner'>\"\r\n                                +result.file+\" line <span class='lineNumber'>\"+result.line+\"</span>\"+column+\"</span>]\"\r\n                        +\"</span> \"\r\n                    +linesDisplay\r\n                    +' <span class=\"expectations\">'+expectations+'</span>'\r\n            +\"</div>\"\r\n        },\r\n        exception: function(exception) {\r\n            if(exception.stack !== undefined) {\r\n                var displayError = exception.stack\r\n            } else {\r\n                var displayError = exception\r\n            }\r\n\r\n            var formattedException = textToHtml(displayError)\r\n            return '<span style=\"color:'+purple+';\">Exception: '+formattedException+'</span>'\r\n        },\r\n        log: function(values) {\r\n            return '<div>'\r\n                +values.map(function(v) {\r\n                    return textToHtml(valueToString(v))\r\n                }).join(', ')\r\n            +'</div>'\r\n\r\n        }\r\n    })\r\n\r\n    return formattedTestHtml.then(function(formattedHtml) {\r\n        return Future('<script src=\"http://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js\"></script>'+\r\n        '<style>\\\r\n            body{\\\r\n                background-color: '+black+';\\\r\n                color: '+white+';\\\r\n            }\\\r\n            h2{\\\r\n                margin-bottom: 5px;\\\r\n                margin-top: 10px;\\\r\n            }\\\r\n            .green\\\r\n            {   color: '+green+';\\\r\n            }\\\r\n            .link\\\r\n            {   cursor:pointer;\\\r\n            }\\\r\n            .primaryTitle {\\\r\n                color: '+blue+';\\\r\n            }\\\r\n            .testResultsName {\\\r\n                color: '+brightBlue+';\\\r\n            }\\\r\n            .asyncTime {\\\r\n                color: '+gray+';\\\r\n            }\\\r\n            .resultsArea{\\\r\n                margin:1px;\\\r\n                margin-bottom: 5px;\\\r\n            }\\\r\n                .resultsAreaInner{\\\r\n                    padding:0 8px;\\\r\n                }\\\r\n                .resultsBar{\\\r\n                    color:white;\\\r\n                    margin-bottom:4px;\\\r\n                    padding: 1px 3px;\\\r\n                }\\\r\n            .testResultsArea{\\\r\n                padding:0 8px;\\\r\n            }\\\r\n            .testResultsBar{\\\r\n                background-color:'+black+';color:white;margin:4px 0;\\\r\n            }\\\r\n                .testResultsBarInner{\\\r\n                    color:white;margin:1px;padding: 1px 3px;\\\r\n                }\\\r\n                \\\r\n            .locationOuter{\\\r\n                color:'+white+';\\\r\n            }\\\r\n            .locationInner, .expectations {\\\r\n                color:'+gray+';\\\r\n            }\\\r\n            .lineNumber{\\\r\n                color:'+white+';\\\r\n            }\\\r\n         </style>'+\r\n        '<script type=\"text/javascript\">                      \\\r\n             var TestDisplayer = ('+getTestDisplayer+')() \\\r\n          </script>'\r\n        +formattedHtml)\r\n    })\r\n}\r\n\r\nvar nextId = 0\r\nvar getMainId = function(name) {\r\n    nextId++\r\n    return 'unitTest_'+nextId//+name.replace(/[^a-zA-Z]/g, \"\") // get rid of all characters except letters\r\n}\r\nvar getNewNumber = function() {\r\n    getNewNumber.n++\r\n    return getNewNumber.n\r\n}\r\ngetNewNumber.n = 0\r\n\r\nfunction plural(num, plural, singular) {\r\n\tvar plur = num!==1;\r\n\r\n    if(singular === undefined) {\r\n    \tif(plur)\treturn \"s\"\r\n        else        return \"\"\r\n    } else {\r\n    \tif(plur)\treturn plural\r\n        else\t\treturn singular\r\n    }\r\n}\r\nfunction htmlEscape(str) {\r\n    return String(str)\r\n            .replace(/&/g, '&amp;')\r\n            .replace(/\"/g, '&quot;')\r\n            .replace(/'/g, '&#39;')\r\n            .replace(/</g, '&lt;')\r\n            .replace(/>/g, '&gt;')\r\n}\r\n\r\nfunction textToHtml(text) {\r\n    return htmlEscape(text)\r\n            .replace(/ /g, '&nbsp;')\r\n            .replace(/\\n/g, \"<br>\\n\")\r\n            .replace(/\\t/g, \"&nbsp;&nbsp;&nbsp;&nbsp;\")\r\n}\r\n\r\nfunction timeText(ms) {\r\n    if(ms < 2000)\r\n        return ms+\"ms\"\r\n    else\r\n        return Number(ms/1000).toPrecision(3)+'s'\r\n}\r\n","\r\nmodule.exports = function(i, str) {\r\n    return i+str.split(\"\\n\")       // get all lines\r\n              .join(\"\\n\"+i)      // join all lines with an indent\r\n}","\"use strict\";\r\n/* Copyright (c) 2014 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n\r\nvar deadunitCore = require(\"./deadunitCore\")\r\nvar Future = require('async-future')\r\nvar stackinfo = require('stackinfo')\r\n\r\nmodule.exports = deadunitCore({\r\n    initialize: function() {},\r\n\r\n    initializeMainTest: function(testState) {\r\n        //testState.active = true // make sure\r\n\r\n        testState.oldOnerror = window.onerror\r\n        testState.newOnerror = window.onerror = function(errorMessage, filename, line, column) {\r\n            //if(testState.active)\r\n                testState.unhandledErrorHandler(\"Uncaught error in \"+filename+\" line \"+line+\"/\"+column+\": \"+errorMessage)\r\n            if(testState.oldOnerror) testState.oldOnerror.apply(this, arguments)\r\n        }\r\n    },\r\n    mainTestDone: function(testState) {\r\n        //testState.active = false // make sure the test-specific onerror code is no longer run\r\n        /*if(testState.newOnerror === window.onerror) {\r\n            window.onerror = testState.oldOnerror // otherwise something else has overwritten onerror, so don't mess with it\r\n        }*/\r\n    },\r\n    runTestGroup: function(deadunitState, tester, runTest, handleError, handleUnhandledError) {\r\n        runTest()\r\n    },\r\n    getScriptSource: function(path) {\r\n        return load(path)\r\n    },\r\n\r\n    defaultUnhandledErrorHandler: function(e) {\r\n        //if(e !== undefined)\r\n            setTimeout(function() {\r\n                if(e.stack)\r\n                    console.log(e.stack)\r\n                else\r\n                    console.log(e)\r\n            },0)\r\n    },\r\n    defaultTestErrorHandler: function(tester) {\r\n        return function(e) {\r\n            tester.manager.emit('exception', {\r\n                parent: tester.mainSubTest.id,\r\n                time: (new Date()).getTime(),\r\n                error: e\r\n            })\r\n        }\r\n    },\r\n\r\n    getLineInfo: function(stackIncrease) {\r\n        return stackinfo()[3+stackIncrease]\r\n    }\r\n})\r\n\r\n\r\nvar loadCache = {}\r\nfunction load(url) {\r\n    if(loadCache[url] !== undefined)\r\n        return loadCache[url]\r\n\r\n    var result = new Future\r\n    try {\r\n        loadCache[url] = result.catch(function(e) {\r\n            // ignore the error\r\n            return undefined // pass on undefined to indicate that the file couldn't be downloaded\r\n        })\r\n\r\n        var httpReq\r\n        var versions = [\"MSXML2.XmlHttp.5.0\",\r\n                        \"MSXML2.XmlHttp.4.0\",\r\n                        \"MSXML2.XmlHttp.3.0\",\r\n                        \"MSXML2.XmlHttp.2.0\",\r\n                        \"Microsoft.XmlHttp\"];\r\n\r\n        if(window.XMLHttpRequest) {\r\n            //    For Mozilla, Safari (non IE browsers)\r\n            httpReq = new XMLHttpRequest();\r\n        } else if( window.ActiveXObject ) {\r\n            //    For IE browsers\r\n            for(var i = 0, n=versions.length; i < n; i++ ) {\r\n                try {\r\n                    httpReq = new ActiveXObject(versions[i]);\r\n                } catch(e) {   }\r\n            }\r\n        }\r\n\r\n        if (!httpReq) {\r\n            throw new Error('Cannot create an XMLHTTP instance')\r\n        }\r\n\r\n        httpReq.onreadystatechange = function() {\r\n            if( httpReq.readyState === 4 ) {\r\n                if( httpReq.status === 200 ) {\r\n                    result.return(httpReq.responseText)\r\n                } else {\r\n                    if(!result.isResolved)\r\n                        result.throw(new Error('Error in request'))\r\n                }\r\n            }\r\n        };\r\n\r\n        httpReq.open('GET', url);\r\n        httpReq.send();\r\n\r\n    } catch(e) {\r\n        if(!result.isResolved)\r\n            result.throw(e)\r\n    }\r\n\r\n    return loadCache[url]\r\n}","\"use strict\";\r\n/* Copyright (c) 2013 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n\r\nvar path = require('path')\r\n\r\nvar proto = require('proto')\r\nvar Future = require('async-future')\r\n\r\nvar processResults = require('./processResults')\r\n\r\n// returns a module intended for a specific environment (that environment being described by the options)\r\n// options can contain:\r\n    // initialization - a function run once that can setup things (like a global error handler).\r\n        // Gets a single parameter 'state' which has the following form:\r\n            // unhandledErrorHandler\r\n    // initializeMainTest - a function run once that can setup things (like a test-specific handler).\r\n        // Gets a single parameter 'mainTestState' which has the following form:\r\n            // unhandledErrorHandler - the error handler for that test\r\n    // runTestGroup - a function run that allows you to wrap the actual test run in some way (intended for node.js domains)\r\n        // gets parameters:\r\n            // state - the same state object sent into `initialization`\r\n            // tester - a UnitTester object for the test\r\n            // runTest - the function that you should call to run the test group. Already has a synchronous try catch inside it (so you don't need to worry about that)\r\n            // handleError - a function that handles an error if one comes up. Takes the error as its only parameter.\r\n    // mainTestDone - a function run once a test is done\r\n        // gets the 'mainTestState' parameter\r\n    // defaultUnhandledErrorHandler - a function that handles an error unhandled by any other handler\r\n        // gets the 'error' as its only parameter\r\n    // defaultTestErrorHandler - is passed the current test, and should return a function that handles an error\r\nmodule.exports = function(options) {\r\n\r\n    // a variable that holds changeable state\r\n    var state = {\r\n        unhandledErrorHandler: options.defaultUnhandledErrorHandler\r\n    }\r\n\r\n    options.initialize(state)\r\n\r\n    // setup default unhandled error handler\r\n    // unhandled errors happen after the test has completed\r\n    function error(handler) {\r\n        state.unhandledErrorHandler = handler\r\n    }\r\n\r\n    // the prototype of objects used to manage accessing and displaying results of a unit test\r\n    var UnitTest = proto(function() {\r\n        this.init = function(/*mainName=undefined, groups*/) {\r\n            var that = this\r\n            var args = arguments\r\n            this.manager = EventManager()\r\n\r\n            setTimeout(function() {\r\n                runTest.call(that, args)\r\n            },0)\r\n        }\r\n\r\n        this.events = function(handlers) {\r\n            this.manager.add(handlers)\r\n            return this\r\n        }\r\n\r\n        this.results = function() {\r\n            return processResults(this)\r\n        }\r\n\r\n        // private\r\n\r\n        function runTest(args) {\r\n            var fakeTest = new UnitTester()\r\n                fakeTest.id = undefined // fake test doesn't get an id\r\n                fakeTest.manager = this.manager\r\n                fakeTest.timeouts = []\r\n                fakeTest.onDoneCallbacks = []\r\n                fakeTest.mainTestState = {get unhandledErrorHandler(){return fakeTest.unhandledErrorHandler || options.defaultTestErrorHandler(fakeTest)}}\r\n\r\n                options.initializeMainTest(fakeTest.mainTestState)\r\n\r\n                timeout(fakeTest, 3000, true) // initial (default) timeout\r\n                fakeTest.onDone = function() { // will execute when this test is done\r\n                    done(fakeTest)\r\n                    options.mainTestDone(fakeTest.mainTestState)\r\n                }\r\n                fakeTest.callOnDone = function(cb) {\r\n                    fakeTest.onDoneCallbacks.push(cb)\r\n                }\r\n\r\n            UnitTester.prototype.test.apply(fakeTest, args) // set so the error handler can access the real test\r\n            this.mainTester = fakeTest\r\n\r\n            fakeTest.groupEnded = true\r\n            checkGroupDone(fakeTest)\r\n        }\r\n    })\r\n\r\n    var EventManager = proto(function() {\r\n\r\n        this.init = function() {\r\n            this.handlers = {\r\n                group: [],\r\n                assert: [],\r\n                count: [],\r\n                exception: [],\r\n                log: [],\r\n                end: [],\r\n                groupEnd: [],\r\n                before: [],\r\n                after: [],\r\n                beforeEnd: [],\r\n                afterEnd: []\r\n            }\r\n\r\n            this.history = []\r\n        }\r\n\r\n        // emits an event\r\n        this.emit = function(type, eventData) {\r\n            this.history.push({type:type, data: eventData})\r\n            this.handlers[type].forEach(function(handler) {\r\n                try {\r\n                    handler.call(undefined, eventData)\r\n                } catch(e) {\r\n                    setTimeout(function() {\r\n                        throw e // throw error asynchronously because these error should be separate from the test exceptions\r\n                    },0)\r\n                }\r\n            })\r\n        }\r\n\r\n        // adds a set of listening handlers to the event stream, and runs those handlers on the stream's history\r\n        this.add = function(handlers) {\r\n            // run the history of events on the the handlers\r\n            this.history.forEach(function(e) {\r\n                if(handlers[e.type] !== undefined) {\r\n                    handlers[e.type].call(undefined, e.data)\r\n                }\r\n            })\r\n\r\n            // then have those handlers listen on future events\r\n            for(var type in handlers) {\r\n                var typeHandlers = this.handlers[type]\r\n                if(typeHandlers === undefined) {\r\n                    throw new Error(\"event type '\"+type+\"' invalid\")\r\n                }\r\n\r\n                typeHandlers.push(handlers[type])\r\n            }\r\n        }\r\n    })\r\n\r\n    function testGroup(tester, test) {\r\n\r\n        // handles any error (synchronous or asynchronous errors)\r\n        var handleError = function(e) {\r\n            tester.manager.emit('exception', {\r\n                parent: tester.id,\r\n                time: now(),\r\n                error: e\r\n            })\r\n        }\r\n\r\n        var runTest = function() {\r\n            try {\r\n                test.call(tester, tester) // tester is both 'this' and the first parameter (for flexibility)\r\n            } catch(e) {\r\n                handleError(e)\r\n            }\r\n        }\r\n\r\n        options.runTestGroup(state, tester, runTest, handleError)\r\n    }\r\n\r\n    // the prototype of objects used to write tests and contain the results of tests\r\n    var UnitTester = function(name, mainTester) {\r\n        if(!mainTester) mainTester = this\r\n\r\n        this.id = groupid()\r\n        this.mainTester = mainTester // the mainTester is used to easily figure out if the test results have been accessed (so early accesses can be detected)\r\n        this.name = name\r\n\r\n        this.doneTests = 0\r\n        this.doneAsserts = 0\r\n        this.runningTests = 0 // the number of subtests created synchronously\r\n        this.waitingAsserts = 0 // since asserting is asynchronous, need to make sure they complete before the test can be declared finished\r\n        this.doneCalled = false\r\n    }\r\n\r\n        UnitTester.prototype = {\r\n            test: function() {\r\n                if(arguments.length === 1) {\r\n                    var test = arguments[0]\r\n\r\n                // named test\r\n                } else {\r\n                    var name = arguments[0]\r\n                    var test = arguments[1]\r\n                }\r\n\r\n                var that = this\r\n                this.runningTests++\r\n\r\n                var tester = new UnitTester(name, this.mainTester)\r\n                tester.manager = this.manager\r\n\r\n                if(this.id === undefined) { // ie its the top-level fake test\r\n                    this.mainSubTest = tester\r\n                }\r\n\r\n                tester.onDone = function() { // will execute when this test is done\r\n                    that.doneTests += 1\r\n\r\n                    that.manager.emit('groupEnd', {\r\n                        id: tester.id,\r\n                        time: now()\r\n                    })\r\n\r\n                    checkGroupDone(that)\r\n                }\r\n\r\n                tester.mainTester.callOnDone(function() {\r\n                    if(!tester.doneCalled) { // a timeout happened - end the test\r\n                        tester.doneCalled = true\r\n                        that.manager.emit('groupEnd', {\r\n                            id: tester.id,\r\n                            time: now()\r\n                        })\r\n                    }\r\n                })\r\n\r\n                this.manager.emit('group', {\r\n                    id: tester.id,\r\n                    parent: this.id,\r\n                    name: name,\r\n                    time: now()\r\n                })\r\n\r\n                if(this.beforeFn) {\r\n                    this.manager.emit('before', {\r\n                        parent: tester.id,\r\n                        time: now()\r\n                    })\r\n\r\n                    this.beforeFn.call(this, this)\r\n\r\n                    this.manager.emit('beforeEnd', {\r\n                        parent: tester.id,\r\n                        time: now()\r\n                    })\r\n                }\r\n\r\n                testGroup(tester, test)\r\n\r\n                if(this.afterFn) {\r\n                    this.manager.emit('after', {\r\n                        parent: tester.id,\r\n                        time: now()\r\n                    })\r\n\r\n                    this.afterFn.call(this, this)\r\n\r\n                    this.manager.emit('afterEnd', {\r\n                        parent: tester.id,\r\n                        time: now()\r\n                    })\r\n                }\r\n\r\n                tester.groupEnded = true\r\n                checkGroupDone(tester)\r\n\r\n                return tester\r\n            },\r\n\r\n            ok: function(success, actualValue, expectedValue) {\r\n                this.doneAsserts += 1\r\n                assert(this, success, actualValue, expectedValue, 'assert', \"ok\").then(function() {\r\n                    this.waitingAsserts --\r\n                    this.mainTester.waitingAsserts --\r\n                    checkGroupDone(this)\r\n                }.bind(this)).done()\r\n            },\r\n            equal: function(expectedValue, testValue) {\r\n                this.doneAsserts += 1\r\n                assert(this, expectedValue === testValue, testValue, expectedValue, 'assert', \"equal\").then(function() {\r\n                    this.waitingAsserts --\r\n                    this.mainTester.waitingAsserts --\r\n                    checkGroupDone(this)\r\n                }.bind(this)).done()\r\n            },\r\n            count: function(number) {\r\n                if(this.countExpected !== undefined)\r\n                    throw Error(\"count called multiple times for this test\")\r\n                this.countExpected = number\r\n\r\n                assert(this, undefined, undefined, number, 'count', \"count\").then(function() {\r\n                    this.waitingAsserts --\r\n                    this.mainTester.waitingAsserts --\r\n                    checkGroupDone(this)\r\n                }.bind(this)).done()\r\n            },\r\n\r\n            before: function(fn) {\r\n                if(this.beforeFn !== undefined)\r\n                    throw Error(\"before called multiple times for this test\")\r\n\r\n                this.beforeFn = fn\r\n            },\r\n            after: function(fn) {\r\n                if(this.afterFn !== undefined)\r\n                    throw Error(\"after called multiple times for this test\")\r\n\r\n                this.afterFn = fn\r\n            },\r\n\r\n            log: function(/*arguments*/) {\r\n                this.manager.emit('log', {\r\n                    parent: this.id,\r\n                    time: now(),\r\n                    values: Array.prototype.slice.call(arguments, 0)\r\n                })\r\n            },\r\n\r\n            timeout: function(t) {\r\n                timeout(this, t, false)\r\n            },\r\n\r\n            error: function(handler) {\r\n                this.unhandledErrorHandler = handler\r\n            }\r\n        }\r\n\r\n    function checkGroupDone(group) {\r\n        if(!group.doneCalled && group.groupEnded === true && group.waitingAsserts === 0\r\n            && ((group.countExpected === undefined || group.countExpected <= group.doneAsserts+group.doneTests)\r\n                && group.runningTests === group.doneTests)\r\n        ) {\r\n            group.doneCalled = true // don't call twice\r\n            group.onDone()\r\n        }\r\n\r\n    }\r\n\r\n    function done(unitTester) {\r\n        if(unitTester.mainTester.ended) {\r\n            unitTester.mainTester.manager.emit('exception', {\r\n                parent: unitTester.mainTester.mainSubTest.id,\r\n                time: now(),\r\n                error: new Error(\"done called more than once (probably because the test timed out before it finished)\")\r\n            })\r\n        } else {\r\n            unitTester.mainTester.timeouts.forEach(function(to) {\r\n                clearTimeout(to)\r\n            })\r\n            unitTester.mainTester.timeouts = []\r\n\r\n            endTest(unitTester, 'normal')\r\n        }\r\n    }\r\n\r\n    // if a timeout is the default, it can be overridden\r\n    function timeout(that, t, theDefault) {\r\n        var to = setTimeout(function() {\r\n            remove(that.mainTester.timeouts, to)\r\n\r\n            if(that.mainTester.timeouts.length === 0 && !that.mainTester.ended) {\r\n                that.mainTester.timingOut = true\r\n                checkIfTestIsReadyToEnd()\r\n            }\r\n\r\n            function checkIfTestIsReadyToEnd() {\r\n                setTimeout(function() {\r\n                    if(that.mainTester.waitingAsserts <= 0) {\r\n                        endTest(that.mainTester, 'timeout')\r\n                    } else {\r\n                        checkIfTestIsReadyToEnd()\r\n                    }\r\n                },10)\r\n            }\r\n        }, t)\r\n\r\n        that.mainTester.timeouts.push(to)\r\n\r\n        if(theDefault) {\r\n            that.mainTester.timeouts.default = to\r\n        } else if(that.mainTester.timeouts.default !== undefined) {\r\n            clearTimeout(that.mainTester.timeouts.default)\r\n            remove(that.mainTester.timeouts, that.mainTester.timeouts.default)\r\n            that.mainTester.timeouts.default = undefined\r\n        }\r\n\r\n        function remove(array, item) {\r\n            var index = array.indexOf(item)\r\n            if(index === -1)\r\n                throw Error(\"Item doesn't exist to remove\")\r\n            array.splice(index, 1)\r\n        }\r\n    }\r\n\r\n    function endTest(that, type) {\r\n        that.mainTester.ended = true\r\n\r\n        if(that.mainTester === that) { // if its the main tester\r\n            that.onDoneCallbacks.forEach(function(cb) {\r\n                cb()\r\n            })\r\n        }\r\n\r\n        that.manager.emit('end', {\r\n            type: type,\r\n            time: now()\r\n        })\r\n    }\r\n\r\n    function assert(that, success, actualValue, expectedValue, type, functionName/*=\"ok\"*/, lineInfo/*=dynamic*/, stackIncrease/*=0*/) {\r\n        if(!stackIncrease) stackIncrease = 1\r\n        if(!functionName) functionName = \"ok\"\r\n        if(!lineInfo)\r\n            var lineInfoFuture = getLineInformation(functionName, stackIncrease)\r\n        else\r\n            var lineInfoFuture = Future(lineInfo)\r\n\r\n        that.waitingAsserts += 1\r\n        if(!that.mainTester.timingOut) {\r\n            that.mainTester.waitingAsserts += 1\r\n        }\r\n\r\n        return lineInfoFuture.then(function(lineInfo) {\r\n            var result = lineInfo\r\n            result.type = 'assert'\r\n            result.success = success\r\n\r\n            if(actualValue !== undefined)     result.actual = actualValue\r\n            if(expectedValue !== undefined)   result.expected = expectedValue\r\n\r\n            result.parent = that.id\r\n            result.time = now()\r\n\r\n            that.manager.emit(type, result)\r\n        })\r\n    }\r\n\r\n\r\n    function getLineInformation(functionName, stackIncrease) {\r\n        var info = options.getLineInfo(stackIncrease)\r\n        return getFunctionCallLines(info.file, functionName, info.line).then(function(sourceLines) {\r\n            return Future({\r\n                sourceLines: sourceLines,\r\n                file: path.basename(info.file),\r\n                line: info.line,\r\n                column: info.column\r\n            })\r\n        })\r\n    }\r\n\r\n    // gets the actual lines of the call\r\n    // todo: make this work when call is over multiple lines (you would need to count parens and check for quotations)\r\n    function getFunctionCallLines(fileName, functionName, lineNumber) {\r\n        return options.getScriptSource(fileName).then(function(file) {\r\n\r\n            if(file !== undefined) {\r\n                var fileLines = file.split(\"\\n\")\r\n\r\n                var lines = []\r\n                for(var n=0; n<true; n++) {\r\n                    var line = fileLines[lineNumber - 1 - n]\r\n                    if(line === undefined) {\r\n                        break;\r\n                    }\r\n\r\n                    lines.push(line.trim())\r\n                    var containsFunction = line.indexOf(functionName) !== -1\r\n                    if(containsFunction) {\r\n                        return Future(lines.reverse().join('\\n'))\r\n                    }\r\n                    if(lineNumber - n < 0) {\r\n                        return Future(\"<no lines found (possibly an error?)> \")\t// something went wrong if this is being returned (the functionName wasn't found above - means you didn't get the function name right)\r\n                    }\r\n                }\r\n            }\r\n            // else\r\n            return Future(\"<source not available>\")\r\n        })\r\n    }\r\n\r\n    function groupid() {\r\n        groupid.next++\r\n        return groupid.next\r\n    }\r\n    groupid.next = -1\r\n\r\n    // returns a Unix Timestamp for now\r\n    function now() {\r\n        return (new Date()).getTime()\r\n    }\r\n\r\n    return {\r\n        error: error,\r\n        test: UnitTest\r\n    }\r\n}","\r\n\r\nmodule.exports = exceptionMode(createException()) // basically what browser this is\r\n\r\n// verbatim from `mode` in stacktrace.js as of 2014-01-23\r\nfunction exceptionMode(e) {\r\n    if (e['arguments'] && e.stack) {\r\n        return 'chrome';\r\n    } else if (e.stack && e.sourceURL) {\r\n        return 'safari';\r\n    } else if (e.stack && e.number) {\r\n        return 'ie';\r\n    } else if (typeof e.message === 'string' && typeof window !== 'undefined' && window.opera) {\r\n        // e.message.indexOf(\"Backtrace:\") > -1 -> opera\r\n        // !e.stacktrace -> opera\r\n        if (!e.stacktrace) {\r\n            return 'opera9'; // use e.message\r\n        }\r\n        // 'opera#sourceloc' in e -> opera9, opera10a\r\n        if (e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\r\n            return 'opera9'; // use e.message\r\n        }\r\n        // e.stacktrace && !e.stack -> opera10a\r\n        if (!e.stack) {\r\n            return 'opera10a'; // use e.stacktrace\r\n        }\r\n        // e.stacktrace && e.stack -> opera10b\r\n        if (e.stacktrace.indexOf(\"called from line\") < 0) {\r\n            return 'opera10b'; // use e.stacktrace, format differs from 'opera10a'\r\n        }\r\n        // e.stacktrace && e.stack -> opera11\r\n        return 'opera11'; // use e.stacktrace, format differs from 'opera10a', 'opera10b'\r\n    } else if (e.stack && !e.fileName) {\r\n        // Chrome 27 does not have e.arguments as earlier versions,\r\n        // but still does not have e.fileName as Firefox\r\n        return 'chrome';\r\n    } else if (e.stack) {\r\n        return 'firefox';\r\n    }\r\n    return 'other';\r\n}\r\n\r\nfunction createException() {\r\n    try {\r\n        this.undef();\r\n    } catch (e) {\r\n        return e;\r\n    }\r\n}\r\n","// Domain Public by Eric Wendelin http://eriwen.com/ (2008)\n//                  Luke Smith http://lucassmith.name/ (2008)\n//                  Loic Dachary <loic@dachary.org> (2008)\n//                  Johan Euphrosine <proppy@aminche.com> (2008)\n//                  Oyvind Sean Kinsey http://kinsey.no/blog (2010)\n//                  Victor Homyakov <victor-homyakov@users.sourceforge.net> (2010)\n(function(global, factory) {\n  // Node\n  if (typeof exports === 'object') {\n    module.exports = factory();\n\n  // AMD\n  } else if (typeof define === 'function' && define.amd) {\n    define(factory);\n\n  // Browser globals\n  } else {\n    global.printStackTrace = factory();\n  }\n}(this, function() {\n\t/**\n\t * Main function giving a function stack trace with a forced or passed in Error\n\t *\n\t * @cfg {Error} e The error to create a stacktrace from (optional)\n\t * @cfg {Boolean} guess If we should try to resolve the names of anonymous functions\n\t * @return {Array} of Strings with functions, lines, files, and arguments where possible\n\t */\n\tfunction printStackTrace(options) {\n\t    options = options || {guess: true};\n\t    var ex = options.e || null, guess = !!options.guess;\n\t    var p = new printStackTrace.implementation(), result = p.run(ex);\n\t    return (guess) ? p.guessAnonymousFunctions(result) : result;\n\t}\n\n\tprintStackTrace.implementation = function() {\n\t};\n\n\tprintStackTrace.implementation.prototype = {\n\t    /**\n\t     * @param {Error} ex The error to create a stacktrace from (optional)\n\t     * @param {String} mode Forced mode (optional, mostly for unit tests)\n\t     */\n\t    run: function(ex, mode) {\n\t        ex = ex || this.createException();\n\t        // examine exception properties w/o debugger\n\t        //for (var prop in ex) {alert(\"Ex['\" + prop + \"']=\" + ex[prop]);}\n\t        mode = mode || this.mode(ex);\n\t        if (mode === 'other') {\n\t            return this.other(arguments.callee);\n\t        } else {\n\t            return this[mode](ex);\n\t        }\n\t    },\n\n\t    createException: function() {\n\t        try {\n\t            this.undef();\n\t        } catch (e) {\n\t            return e;\n\t        }\n\t    },\n\n\t    /**\n\t     * Mode could differ for different exception, e.g.\n\t     * exceptions in Chrome may or may not have arguments or stack.\n\t     *\n\t     * @return {String} mode of operation for the exception\n\t     */\n\t    mode: function(e) {\n\t        if (e['arguments'] && e.stack) {\n\t            return 'chrome';\n\t        } else if (e.stack && e.sourceURL) {\n\t            return 'safari';\n\t        } else if (e.stack && e.number) {\n\t            return 'ie';\n\t        } else if (typeof e.message === 'string' && typeof window !== 'undefined' && window.opera) {\n\t            // e.message.indexOf(\"Backtrace:\") > -1 -> opera\n\t            // !e.stacktrace -> opera\n\t            if (!e.stacktrace) {\n\t                return 'opera9'; // use e.message\n\t            }\n\t            // 'opera#sourceloc' in e -> opera9, opera10a\n\t            if (e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\n\t                return 'opera9'; // use e.message\n\t            }\n\t            // e.stacktrace && !e.stack -> opera10a\n\t            if (!e.stack) {\n\t                return 'opera10a'; // use e.stacktrace\n\t            }\n\t            // e.stacktrace && e.stack -> opera10b\n\t            if (e.stacktrace.indexOf(\"called from line\") < 0) {\n\t                return 'opera10b'; // use e.stacktrace, format differs from 'opera10a'\n\t            }\n\t            // e.stacktrace && e.stack -> opera11\n\t            return 'opera11'; // use e.stacktrace, format differs from 'opera10a', 'opera10b'\n\t        } else if (e.stack && !e.fileName) {\n\t            // Chrome 27 does not have e.arguments as earlier versions,\n\t            // but still does not have e.fileName as Firefox\n\t            return 'chrome';\n\t        } else if (e.stack) {\n\t            return 'firefox';\n\t        }\n\t        return 'other';\n\t    },\n\n\t    /**\n\t     * Given a context, function name, and callback function, overwrite it so that it calls\n\t     * printStackTrace() first with a callback and then runs the rest of the body.\n\t     *\n\t     * @param {Object} context of execution (e.g. window)\n\t     * @param {String} functionName to instrument\n\t     * @param {Function} callback function to call with a stack trace on invocation\n\t     */\n\t    instrumentFunction: function(context, functionName, callback) {\n\t        context = context || window;\n\t        var original = context[functionName];\n\t        context[functionName] = function instrumented() {\n\t            callback.call(this, printStackTrace().slice(4));\n\t            return context[functionName]._instrumented.apply(this, arguments);\n\t        };\n\t        context[functionName]._instrumented = original;\n\t    },\n\n\t    /**\n\t     * Given a context and function name of a function that has been\n\t     * instrumented, revert the function to it's original (non-instrumented)\n\t     * state.\n\t     *\n\t     * @param {Object} context of execution (e.g. window)\n\t     * @param {String} functionName to de-instrument\n\t     */\n\t    deinstrumentFunction: function(context, functionName) {\n\t        if (context[functionName].constructor === Function &&\n\t                context[functionName]._instrumented &&\n\t                context[functionName]._instrumented.constructor === Function) {\n\t            context[functionName] = context[functionName]._instrumented;\n\t        }\n\t    },\n\n\t    /**\n\t     * Given an Error object, return a formatted Array based on Chrome's stack string.\n\t     *\n\t     * @param e - Error object to inspect\n\t     * @return Array<String> of function calls, files and line numbers\n\t     */\n\t    chrome: function(e) {\n\t        var stack = (e.stack + '\\n').replace(/^\\S[^\\(]+?[\\n$]/gm, '').\n\t          replace(/^\\s+(at eval )?at\\s+/gm, '').\n\t          replace(/^([^\\(]+?)([\\n$])/gm, '{anonymous}()@$1$2').\n\t          replace(/^Object.<anonymous>\\s*\\(([^\\)]+)\\)/gm, '{anonymous}()@$1').split('\\n');\n\t        stack.pop();\n\t        return stack;\n\t    },\n\n\t    /**\n\t     * Given an Error object, return a formatted Array based on Safari's stack string.\n\t     *\n\t     * @param e - Error object to inspect\n\t     * @return Array<String> of function calls, files and line numbers\n\t     */\n\t    safari: function(e) {\n\t        return e.stack.replace(/\\[native code\\]\\n/m, '')\n\t            .replace(/^(?=\\w+Error\\:).*$\\n/m, '')\n\t            .replace(/^@/gm, '{anonymous}()@')\n\t            .split('\\n');\n\t    },\n\n\t    /**\n\t     * Given an Error object, return a formatted Array based on IE's stack string.\n\t     *\n\t     * @param e - Error object to inspect\n\t     * @return Array<String> of function calls, files and line numbers\n\t     */\n\t    ie: function(e) {\n\t        var lineRE = /^.*at (\\w+) \\(([^\\)]+)\\)$/gm;\n\t        return e.stack.replace(/at Anonymous function /gm, '{anonymous}()@')\n\t            .replace(/^(?=\\w+Error\\:).*$\\n/m, '')\n\t            .replace(lineRE, '$1@$2')\n\t            .split('\\n');\n\t    },\n\n\t    /**\n\t     * Given an Error object, return a formatted Array based on Firefox's stack string.\n\t     *\n\t     * @param e - Error object to inspect\n\t     * @return Array<String> of function calls, files and line numbers\n\t     */\n\t    firefox: function(e) {\n\t        return e.stack.replace(/(?:\\n@:0)?\\s+$/m, '').replace(/^[\\(@]/gm, '{anonymous}()@').split('\\n');\n\t    },\n\n\t    opera11: function(e) {\n\t        var ANON = '{anonymous}', lineRE = /^.*line (\\d+), column (\\d+)(?: in (.+))? in (\\S+):$/;\n\t        var lines = e.stacktrace.split('\\n'), result = [];\n\n\t        for (var i = 0, len = lines.length; i < len; i += 2) {\n\t            var match = lineRE.exec(lines[i]);\n\t            if (match) {\n\t                var location = match[4] + ':' + match[1] + ':' + match[2];\n\t                var fnName = match[3] || \"global code\";\n\t                fnName = fnName.replace(/<anonymous function: (\\S+)>/, \"$1\").replace(/<anonymous function>/, ANON);\n\t                result.push(fnName + '@' + location + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\n\t            }\n\t        }\n\n\t        return result;\n\t    },\n\n\t    opera10b: function(e) {\n\t        // \"<anonymous function: run>([arguments not available])@file://localhost/G:/js/stacktrace.js:27\\n\" +\n\t        // \"printStackTrace([arguments not available])@file://localhost/G:/js/stacktrace.js:18\\n\" +\n\t        // \"@file://localhost/G:/js/test/functional/testcase1.html:15\"\n\t        var lineRE = /^(.*)@(.+):(\\d+)$/;\n\t        var lines = e.stacktrace.split('\\n'), result = [];\n\n\t        for (var i = 0, len = lines.length; i < len; i++) {\n\t            var match = lineRE.exec(lines[i]);\n\t            if (match) {\n\t                var fnName = match[1]? (match[1] + '()') : \"global code\";\n\t                result.push(fnName + '@' + match[2] + ':' + match[3]);\n\t            }\n\t        }\n\n\t        return result;\n\t    },\n\n\t    /**\n\t     * Given an Error object, return a formatted Array based on Opera 10's stacktrace string.\n\t     *\n\t     * @param e - Error object to inspect\n\t     * @return Array<String> of function calls, files and line numbers\n\t     */\n\t    opera10a: function(e) {\n\t        // \"  Line 27 of linked script file://localhost/G:/js/stacktrace.js\\n\"\n\t        // \"  Line 11 of inline#1 script in file://localhost/G:/js/test/functional/testcase1.html: In function foo\\n\"\n\t        var ANON = '{anonymous}', lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n\t        var lines = e.stacktrace.split('\\n'), result = [];\n\n\t        for (var i = 0, len = lines.length; i < len; i += 2) {\n\t            var match = lineRE.exec(lines[i]);\n\t            if (match) {\n\t                var fnName = match[3] || ANON;\n\t                result.push(fnName + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\n\t            }\n\t        }\n\n\t        return result;\n\t    },\n\n\t    // Opera 7.x-9.2x only!\n\t    opera9: function(e) {\n\t        // \"  Line 43 of linked script file://localhost/G:/js/stacktrace.js\\n\"\n\t        // \"  Line 7 of inline#1 script in file://localhost/G:/js/test/functional/testcase1.html\\n\"\n\t        var ANON = '{anonymous}', lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n\t        var lines = e.message.split('\\n'), result = [];\n\n\t        for (var i = 2, len = lines.length; i < len; i += 2) {\n\t            var match = lineRE.exec(lines[i]);\n\t            if (match) {\n\t                result.push(ANON + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\n\t            }\n\t        }\n\n\t        return result;\n\t    },\n\n\t    // Safari 5-, IE 9-, and others\n\t    other: function(curr) {\n\t        var ANON = '{anonymous}', fnRE = /function\\s*([\\w\\-$]+)?\\s*\\(/i, stack = [], fn, args, maxStackSize = 10;\n\t        while (curr && curr['arguments'] && stack.length < maxStackSize) {\n\t            fn = fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON;\n\t            args = Array.prototype.slice.call(curr['arguments'] || []);\n\t            stack[stack.length] = fn + '(' + this.stringifyArguments(args) + ')';\n\t            curr = curr.caller;\n\t        }\n\t        return stack;\n\t    },\n\n\t    /**\n\t     * Given arguments array as a String, substituting type names for non-string types.\n\t     *\n\t     * @param {Arguments,Array} args\n\t     * @return {String} stringified arguments\n\t     */\n\t    stringifyArguments: function(args) {\n\t        var result = [];\n\t        var slice = Array.prototype.slice;\n\t        for (var i = 0; i < args.length; ++i) {\n\t            var arg = args[i];\n\t            if (arg === undefined) {\n\t                result[i] = 'undefined';\n\t            } else if (arg === null) {\n\t                result[i] = 'null';\n\t            } else if (arg.constructor) {\n\t                if (arg.constructor === Array) {\n\t                    if (arg.length < 3) {\n\t                        result[i] = '[' + this.stringifyArguments(arg) + ']';\n\t                    } else {\n\t                        result[i] = '[' + this.stringifyArguments(slice.call(arg, 0, 1)) + '...' + this.stringifyArguments(slice.call(arg, -1)) + ']';\n\t                    }\n\t                } else if (arg.constructor === Object) {\n\t                    result[i] = '#object';\n\t                } else if (arg.constructor === Function) {\n\t                    result[i] = '#function';\n\t                } else if (arg.constructor === String) {\n\t                    result[i] = '\"' + arg + '\"';\n\t                } else if (arg.constructor === Number) {\n\t                    result[i] = arg;\n\t                }\n\t            }\n\t        }\n\t        return result.join(',');\n\t    },\n\n\t    sourceCache: {},\n\n\t    /**\n\t     * @return the text from a given URL\n\t     */\n\t    ajax: function(url) {\n\t        var req = this.createXMLHTTPObject();\n\t        if (req) {\n\t            try {\n\t                req.open('GET', url, false);\n\t                //req.overrideMimeType('text/plain');\n\t                //req.overrideMimeType('text/javascript');\n\t                req.send(null);\n\t                //return req.status == 200 ? req.responseText : '';\n\t                return req.responseText;\n\t            } catch (e) {\n\t            }\n\t        }\n\t        return '';\n\t    },\n\n\t    /**\n\t     * Try XHR methods in order and store XHR factory.\n\t     *\n\t     * @return <Function> XHR function or equivalent\n\t     */\n\t    createXMLHTTPObject: function() {\n\t        var xmlhttp, XMLHttpFactories = [\n\t            function() {\n\t                return new XMLHttpRequest();\n\t            }, function() {\n\t                return new ActiveXObject('Msxml2.XMLHTTP');\n\t            }, function() {\n\t                return new ActiveXObject('Msxml3.XMLHTTP');\n\t            }, function() {\n\t                return new ActiveXObject('Microsoft.XMLHTTP');\n\t            }\n\t        ];\n\t        for (var i = 0; i < XMLHttpFactories.length; i++) {\n\t            try {\n\t                xmlhttp = XMLHttpFactories[i]();\n\t                // Use memoization to cache the factory\n\t                this.createXMLHTTPObject = XMLHttpFactories[i];\n\t                return xmlhttp;\n\t            } catch (e) {\n\t            }\n\t        }\n\t    },\n\n\t    /**\n\t     * Given a URL, check if it is in the same domain (so we can get the source\n\t     * via Ajax).\n\t     *\n\t     * @param url <String> source url\n\t     * @return <Boolean> False if we need a cross-domain request\n\t     */\n\t    isSameDomain: function(url) {\n\t        return typeof location !== \"undefined\" && url.indexOf(location.hostname) !== -1; // location may not be defined, e.g. when running from nodejs.\n\t    },\n\n\t    /**\n\t     * Get source code from given URL if in the same domain.\n\t     *\n\t     * @param url <String> JS source URL\n\t     * @return <Array> Array of source code lines\n\t     */\n\t    getSource: function(url) {\n\t        // TODO reuse source from script tags?\n\t        if (!(url in this.sourceCache)) {\n\t            this.sourceCache[url] = this.ajax(url).split('\\n');\n\t        }\n\t        return this.sourceCache[url];\n\t    },\n\n\t    guessAnonymousFunctions: function(stack) {\n\t        for (var i = 0; i < stack.length; ++i) {\n\t            var reStack = /\\{anonymous\\}\\(.*\\)@(.*)/,\n\t                reRef = /^(.*?)(?::(\\d+))(?::(\\d+))?(?: -- .+)?$/,\n\t                frame = stack[i], ref = reStack.exec(frame);\n\n\t            if (ref) {\n\t                var m = reRef.exec(ref[1]);\n\t                if (m) { // If falsey, we did not get any file/line information\n\t                    var file = m[1], lineno = m[2], charno = m[3] || 0;\n\t                    if (file && this.isSameDomain(file) && lineno) {\n\t                        var functionName = this.guessAnonymousFunction(file, lineno, charno);\n\t                        stack[i] = frame.replace('{anonymous}', functionName);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return stack;\n\t    },\n\n\t    guessAnonymousFunction: function(url, lineNo, charNo) {\n\t        var ret;\n\t        try {\n\t            ret = this.findFunctionName(this.getSource(url), lineNo);\n\t        } catch (e) {\n\t            ret = 'getSource failed with url: ' + url + ', exception: ' + e.toString();\n\t        }\n\t        return ret;\n\t    },\n\n\t    findFunctionName: function(source, lineNo) {\n\t        // FIXME findFunctionName fails for compressed source\n\t        // (more than one function on the same line)\n\t        // function {name}({args}) m[1]=name m[2]=args\n\t        var reFunctionDeclaration = /function\\s+([^(]*?)\\s*\\(([^)]*)\\)/;\n\t        // {name} = function ({args}) TODO args capture\n\t        // /['\"]?([0-9A-Za-z_]+)['\"]?\\s*[:=]\\s*function(?:[^(]*)/\n\t        var reFunctionExpression = /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*function\\b/;\n\t        // {name} = eval()\n\t        var reFunctionEvaluation = /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/;\n\t        // Walk backwards in the source lines until we find\n\t        // the line which matches one of the patterns above\n\t        var code = \"\", line, maxLines = Math.min(lineNo, 20), m, commentPos;\n\t        for (var i = 0; i < maxLines; ++i) {\n\t            // lineNo is 1-based, source[] is 0-based\n\t            line = source[lineNo - i - 1];\n\t            commentPos = line.indexOf('//');\n\t            if (commentPos >= 0) {\n\t                line = line.substr(0, commentPos);\n\t            }\n\t            // TODO check other types of comments? Commented code may lead to false positive\n\t            if (line) {\n\t                code = line + code;\n\t                m = reFunctionExpression.exec(code);\n\t                if (m && m[1]) {\n\t                    return m[1];\n\t                }\n\t                m = reFunctionDeclaration.exec(code);\n\t                if (m && m[1]) {\n\t                    //return m[1] + \"(\" + (m[2] || \"\") + \")\";\n\t                    return m[1];\n\t                }\n\t                m = reFunctionEvaluation.exec(code);\n\t                if (m && m[1]) {\n\t                    return m[1];\n\t                }\n\t            }\n\t        }\n\t        return '(?)';\n\t    }\n\t};\n\n\treturn printStackTrace;\n}));","var printStackTrace = require('stacktrace-js')\r\nvar parsers = require('./tracelineParser')\r\nvar mode = require('./exceptionMode')\r\n\r\nmodule.exports = function(ex) {\r\n    if(parsers[mode] === undefined)\r\n        throw new Error(\"browser \"+mode+\" not supported\")\r\n\r\n    var trace = printStackTrace(ex)\r\n\r\n    if(ex === undefined) {\r\n        trace.splice(0,4) // strip stacktrace-js internals\r\n    }\r\n\r\n    return parseStacktrace(trace)\r\n}\r\n\r\nfunction TraceInfo(traceline) {\r\n    this.traceline = traceline\r\n}\r\nTraceInfo.prototype = {\r\n    get file() {\r\n        return getInfo(this).file\r\n    },\r\n    get fn() {\r\n        return getInfo(this).function\r\n    },\r\n    get line() {\r\n        return getInfo(this).line\r\n    },\r\n    get column() {\r\n        return getInfo(this).column\r\n    },\r\n    get info() {\r\n        return getInfo(this)\r\n    }\r\n}\r\n\r\nfunction getInfo(traceInfo) {\r\n    if(traceInfo.cache === undefined) {\r\n        traceInfo.cache = parsers[mode](traceInfo.traceline)\r\n    }\r\n\r\n    return traceInfo.cache\r\n}\r\n\r\nfunction parseStacktrace(trace) {\r\n    var results = []\r\n    for(var n = 0; n<trace.length; n++) {\r\n        results.push(new TraceInfo(trace[n]))\r\n    }\r\n    return results\r\n}\r\n\r\n// here because i'm lazy, they're here for testing only\r\nmodule.exports.parsers = parsers\r\nmodule.exports.mode = mode","\r\nmodule.exports = {\r\n    chrome: function(line) {\r\n        var m = line.match(CHROME_STACK_LINE);\r\n        if (m) {\r\n            var file = m[9] || m[17] || m[24]\r\n            var fn = m[4] || m[7] || m[13] || m[21]\r\n            var lineNumber = m[11] || m[19]\r\n            var column = m[12] || m[20]\r\n        } else {\r\n            //throw new Error(\"Couldn't parse exception line: \"+line)\r\n        }\r\n        \r\n        return {\r\n            file: file,\r\n            function: fn,\r\n            line: lineNumber,\r\n            column: column\r\n        }\r\n    },\r\n    \r\n    firefox: function(line) {\r\n        var m = line.match(FIREFOX_STACK_LINE);\r\n        if (m) {\r\n            var file = m[8]\r\n            var fn = m[1]\r\n            var lineNumber = m[10]\r\n        }\r\n        \r\n        return {\r\n            file: file,\r\n            function: fn,\r\n            line: lineNumber\r\n        }\r\n    },\r\n    \r\n    ie: function(line) {\r\n        var m = line.match(IE_STACK_LINE);\r\n        if (m) {\r\n            var file = m[3] || m[9]\r\n            var fn = m[2] || m[8]\r\n            var lineNumber = m[5] || m[11]\r\n            var column = m[6] || m[12]\r\n        }\r\n        \r\n        return {\r\n            file: file,\r\n            function: fn,\r\n            line: lineNumber,\r\n            column: column\r\n        }\r\n    }\r\n}\r\n\r\n// The following 2 regex patterns were originally taken from google closure library: https://code.google.com/p/closure-library/source/browse/closure/goog/testing/stacktrace.js\r\n// RegExp pattern for JavaScript identifiers. We don't support Unicode identifiers defined in ECMAScript v3.\r\nvar IDENTIFIER_PATTERN_ = '[a-zA-Z_$][\\\\w$]*';\r\n// RegExp pattern for an URL + position inside the file.\r\nvar URL_PATTERN_ = '((?:http|https|file)://[^\\\\s)]+|javascript:.*)';\r\n\r\nvar STACKTRACE_JS_GETSOURCE_FAILURE = 'getSource failed with url'\r\n\r\nvar CHROME_STACKTRACE_JS_GETSOURCE_FAILURE = STACKTRACE_JS_GETSOURCE_FAILURE+'((?!'+'\\\\(\\\\)@'+').)*'\r\n\r\nvar CHROME_FILE_AND_LINE = URL_PATTERN_+'(:(\\\\d*):(\\\\d*))'\r\nvar CHROME_IDENTIFIER_PATTERN = '\\\\<?'+IDENTIFIER_PATTERN_+'\\\\>?'\r\nvar CHROME_COMPOUND_IDENTIFIER = \"((new )?\"+CHROME_IDENTIFIER_PATTERN+'(\\\\.'+CHROME_IDENTIFIER_PATTERN+')*)( \\\\[as '+IDENTIFIER_PATTERN_+'])?'\r\nvar CHROME_UNKNOWN_IDENTIFIER = \"(\\\\(\\\\?\\\\))\"\r\n\r\n// output from stacktrace.js is: \"name()@...\" instead of \"name (...)\"\r\nvar CHROME_ANONYMOUS_FUNCTION = '('+CHROME_STACKTRACE_JS_GETSOURCE_FAILURE+'|'+CHROME_COMPOUND_IDENTIFIER+'|'+CHROME_UNKNOWN_IDENTIFIER+')'\r\n                                    +'\\\\(\\\\)'+'@'+CHROME_FILE_AND_LINE\r\nvar CHROME_NORMAL_FUNCTION = CHROME_COMPOUND_IDENTIFIER+' \\\\('+CHROME_FILE_AND_LINE+'\\\\)'\r\nvar CHROME_NATIVE_FUNCTION = CHROME_COMPOUND_IDENTIFIER+' (\\\\(native\\\\))'\r\n\r\nvar CHROME_FUNCTION_CALL = '('+CHROME_ANONYMOUS_FUNCTION+\"|\"+CHROME_NORMAL_FUNCTION+\"|\"+CHROME_NATIVE_FUNCTION+')'\r\n\r\nvar CHROME_STACK_LINE = new RegExp('^'+CHROME_FUNCTION_CALL+'$')  // precompile them so its faster\r\n\r\n\r\nvar FIREFOX_STACKTRACE_JS_GETSOURCE_FAILURE = STACKTRACE_JS_GETSOURCE_FAILURE+'((?!'+'\\\\(\\\\)@'+').)*'+'\\\\(\\\\)'\r\nvar FIREFOX_FILE_AND_LINE = URL_PATTERN_+'(:(\\\\d*))'\r\nvar FIREFOX_ARRAY_PART = '\\\\[\\\\d*\\\\]'\r\nvar FIREFOX_WEIRD_PART = '\\\\(\\\\?\\\\)'\r\nvar FIREFOX_COMPOUND_IDENTIFIER = '(('+IDENTIFIER_PATTERN_+'|'+FIREFOX_ARRAY_PART+'|'+FIREFOX_WEIRD_PART+')((\\\\(\\\\))?|(\\\\.|\\\\<|/)*))*'\r\nvar FIREFOX_FUNCTION_CALL = '('+FIREFOX_COMPOUND_IDENTIFIER+'|'+FIREFOX_STACKTRACE_JS_GETSOURCE_FAILURE+')@'+FIREFOX_FILE_AND_LINE\r\nvar FIREFOX_STACK_LINE = new RegExp('^'+FIREFOX_FUNCTION_CALL+'$')\r\n\r\nvar IE_WHITESPACE = '[\\\\w \\\\t]'\r\nvar IE_FILE_AND_LINE = CHROME_FILE_AND_LINE\r\nvar IE_ANONYMOUS = '('+IE_WHITESPACE+'*({anonymous}\\\\(\\\\)))@\\\\('+IE_FILE_AND_LINE+'\\\\)'\r\nvar IE_NORMAL_FUNCTION = '('+IDENTIFIER_PATTERN_+')@'+IE_FILE_AND_LINE\r\nvar IE_FUNCTION_CALL = '('+IE_NORMAL_FUNCTION+'|'+IE_ANONYMOUS+')'+IE_WHITESPACE+'*'\r\nvar IE_STACK_LINE = new RegExp('^'+IE_FUNCTION_CALL+'$')","module.exports = function returnResults(unitTestObject) {\r\n\r\n    var results;\r\n    var groups = {}\r\n    var groupMetadata = {}\r\n\r\n    var primaryGroup;\r\n    var ended = false\r\n\r\n    unitTestObject.events({\r\n        group: function(e) {\r\n            var g = {\r\n               parent: e.parent,\r\n               id: e.id,              // a unique id for the test group\r\n               type: 'group',         // indicates a test group (either a `Unit.test` call or `this.test`)\r\n               name: e.name,          // the name of the test\r\n               results: [],           // An array of test results, which can be of an `UnitTest` Result Types\r\n               exceptions: [],        // An array of uncaught exceptions thrown in the test,\r\n               time: e.time,\r\n               duration: 0            // the duration of the test from its start til the last test action (assert, log, etc)\r\n               //                       including asynchronous parts and including subtests\r\n               //syncDuration: _,      // the synchronous duration of the test (not including any asynchronous parts)\r\n               //totalSyncDuration: _  // syncDuration plus the before and after (if applicable)\r\n            }\r\n\r\n            if(primaryGroup === undefined) primaryGroup = g\r\n\r\n            groups[e.id] = g\r\n            groupMetadata[e.id] = {}\r\n            if(e.parent === undefined) {\r\n                results = g\r\n            } else {\r\n                groups[e.parent].results.push(g)\r\n            }\r\n        },\r\n        assert: function(e) {\r\n            e.type = 'assert'\r\n            groups[e.parent].results.push(e)\r\n            setGroupDuration(e.parent, e.time)\r\n        },\r\n        count: function(e) {\r\n            e.type = 'assert'\r\n            setGroupDuration(e.parent, e.time)\r\n\r\n            groupMetadata[e.parent].countInfo = e\r\n        },\r\n        exception: function(e) {\r\n            groups[e.parent].exceptions.push(e.error)\r\n            setGroupDuration(e.parent, e.time)\r\n        },\r\n        log: function(e) {\r\n            e.type = 'log'\r\n            groups[e.parent].results.push(e)\r\n            setGroupDuration(e.parent, e.time)\r\n        },\r\n        before: function(e) {\r\n            groups[e.parent].beforeStart = e.time\r\n        },\r\n        after: function(e) {\r\n            groups[e.parent].afterStart = e.time\r\n        },\r\n        beforeEnd: function(e) {\r\n            groups[e.parent].beforeDuration = e.time - groups[e.parent].beforeStart\r\n        },\r\n        afterEnd: function(e) {\r\n            groups[e.parent].afterDuration = e.time - groups[e.parent].afterStart\r\n        },\r\n        groupEnd: function(e) {\r\n            setGroupDuration(e.id, e.time)\r\n        },\r\n        end: function(e) {\r\n            primaryGroup.timeout = e.type === 'timeout'\r\n\r\n            // make the count assertions\r\n            eachTest(primaryGroup, function(subtest, parenttest) {\r\n                var countInfo = groupMetadata[subtest.id].countInfo\r\n                if(countInfo !== undefined) {\r\n                    var info = countInfo\r\n                    var actualCount = 0\r\n                    subtest.results.forEach(function(a) {\r\n                        if(a.type === 'assert' || a.type === 'group')\r\n                            actualCount++\r\n                    })\r\n\r\n                    subtest.results.push({\r\n                        parent: subtest.id,\r\n                        type: 'assert',\r\n                        success: actualCount === info.expected,\r\n                        time: info.time,\r\n                        sourceLines: info.sourceLines,\r\n                        file: info.file,\r\n                        line: info.line,\r\n                        column: info.column,\r\n                        expected: info.expected,\r\n                        actual: actualCount\r\n                    })\r\n                }\r\n            })\r\n\r\n            ended = true\r\n        }\r\n    })\r\n\r\n    function setGroupDuration(groupid, time) {\r\n        groups[groupid].duration = time - groups[groupid].time\r\n        if(groups[groupid].parent) {\r\n            setGroupDuration(groups[groupid].parent, time)\r\n        }\r\n    }\r\n\r\n    return results\r\n}\r\n\r\n\r\n// iterates through the tests and subtests leaves first (depth first)\r\nfunction eachTest(test, callback, parent) {\r\n    test.results.forEach(function(result) {\r\n        if(result.type === 'group') {\r\n            eachTest(result, callback, test)\r\n        }\r\n    })\r\n\r\n    callback(test, parent)\r\n}","module.exports = \"I'm not really a source map\"","module.exports = \"var someJavascript = {\\r\\n\\r\\n}\\r\\n\\r\\n//@ sourceMappingURL=testResources/source.map.js\"","module.exports = \"var someJavascript = {\\r\\n\\r\\n}\\r\\n\\r\\n//# sourceMappingURL=testResources/source.map.js\"","module.exports = \"var someJavascript = {\\r\\n\\r\\n}\"","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n","var ajax = require('ajax')\r\nvar Future = require(\"async-future\")\r\n\r\n\r\nexports.fromUrl = function(sourceUrl, toSource) {\r\n    if(toSource === undefined) toSource = false\r\n\r\n    return ajax(sourceUrl, true).then(function(response) {\r\n        var sourcemapUrl = getSourceMapUrl(response.headers, response.text)\r\n        if(toSource) {\r\n            return ajax(sourcemapUrl).then(function(response) {\r\n                return Future(response.text)\r\n            })\r\n        } else {\r\n            return Future(sourcemapUrl)\r\n        }\r\n    })\r\n\r\n}\r\n\r\nexports.fromSource = function(sourceText, toSource) {\r\n    if(toSource === undefined) toSource = false\r\n\r\n    var sourcemapUrl = getSourceMapUrl({}, sourceText)\r\n    if(toSource) {\r\n        return ajax(sourcemapUrl).then(function(response) {\r\n            return Future(response.text)\r\n        })\r\n    } else {\r\n        return Future(sourcemapUrl)\r\n    }\r\n}\r\n\r\nexports.cacheGet = ajax.cacheGet\r\nexports.cacheSet = ajax.cacheSet\r\n\r\n\r\n\r\nvar URL_PATTERN = '(((?:http|https|file)://)?[^\\\\s)]+|javascript:.*)'\r\nvar SOURCE_MAP_PATTERN_PART = \" sourceMappingURL=(\"+URL_PATTERN+\")\"\r\nvar SOURCE_MAP_PATTERN1 = \"\\/\\/#\"+SOURCE_MAP_PATTERN_PART\r\nvar SOURCE_MAP_PATTERN2 = \"\\/\\/@\"+SOURCE_MAP_PATTERN_PART\r\n\r\nfunction getSourceMapUrl(headers, content) {\r\n    if(headers['SourceMap'] !== undefined) {\r\n        return headers['SourceMap']\r\n    } else if(headers['X-SourceMap']) {\r\n        return headers['X-SourceMap']\r\n    } else {\r\n        var match = content.match(SOURCE_MAP_PATTERN1)\r\n        if(match !== null) return match[1]\r\n\r\n        match = content.match(SOURCE_MAP_PATTERN2)\r\n        if(match !== null) return match[1]\r\n    }\r\n}","\r\nvar find = require('../sourcemap-locator')\r\n\r\nvar sourceMapFilePath = \"testResources/source.map.js\"\r\n\r\nmodule.exports = function(getFileContents) {\r\n    var sourceMapFileContents = getFileContents(sourceMapFilePath)\r\n\r\n    return {\r\n        fromUrl: function(t) {\r\n            this.count(4)\r\n\r\n            find.fromUrl(\"testResources/sourceFileHashSymbol.js\").then(function(sourcemapUrl) {\r\n                t.ok(sourcemapUrl === sourceMapFilePath)\r\n            }).done()\r\n            find.fromUrl(\"testResources/sourceFileAtSymbol.js\").then(function(sourcemapUrl) {\r\n                t.ok(sourcemapUrl === sourceMapFilePath)\r\n            }).done()\r\n            find.fromUrl(\"testResources/sourceFile_SourceMapHeader.js\").then(function(sourcemapUrl) {\r\n                t.ok(sourcemapUrl === sourceMapFilePath)\r\n            }).done()\r\n            find.fromUrl(\"testResources/sourceFile_X-SourceMapHeader.js\").then(function(sourcemapUrl) {\r\n                t.ok(sourcemapUrl === sourceMapFilePath)\r\n            }).done()\r\n        },\r\n        fromUrlToSource: function(t) {\r\n            this.count(4)\r\n\r\n            find.fromUrl(\"testResources/sourceFileHashSymbol.js\", true).then(function(sourcemapContents) {\r\n                t.ok(sourcemapContents === sourceMapFileContents)\r\n            }).done()\r\n            find.fromUrl(\"testResources/sourceFileAtSymbol.js\", true).then(function(sourcemapContents) {\r\n                t.ok(sourcemapContents === sourceMapFileContents)\r\n            }).done()\r\n            find.fromUrl(\"testResources/sourceFile_SourceMapHeader.js\", true).then(function(sourcemapContents) {\r\n                t.ok(sourcemapContents === sourceMapFileContents)\r\n            }).done()\r\n            find.fromUrl(\"testResources/sourceFile_X-SourceMapHeader.js\", true).then(function(sourcemapContents) {\r\n                t.ok(sourcemapContents === sourceMapFileContents)\r\n            }).done()\r\n        },\r\n        fromSource: function(t) {\r\n            this.count(2)\r\n\r\n            find.fromSource(getFileContents(\"testResources/sourceFileHashSymbol.js\")).then(function(sourcemapUrl) {\r\n                t.ok(sourcemapUrl === sourceMapFilePath, sourcemapUrl)\r\n            }).done()\r\n            find.fromSource(getFileContents(\"testResources/sourceFileAtSymbol.js\")).then(function(sourcemapUrl) {\r\n                t.ok(sourcemapUrl === sourceMapFilePath, sourcemapUrl)\r\n            }).done()\r\n        },\r\n        fromSourceToSource: function(t) {\r\n            this.count(2)\r\n\r\n            find.fromSource(getFileContents(\"testResources/sourceFileHashSymbol.js\"), true).then(function(sourcemapContents) {\r\n                t.ok(sourcemapContents === sourceMapFileContents, sourcemapContents, sourceMapFileContents)\r\n            }).done()\r\n            find.fromSource(getFileContents(\"testResources/sourceFileAtSymbol.js\"), true).then(function(sourcemapContents) {\r\n                t.ok(sourcemapContents === sourceMapFileContents, sourcemapContents, sourceMapFileContents)\r\n            }).done()\r\n        }\r\n    }\r\n}","/* Copyright (c) 2013 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n\r\nvar trimArgs = require(\"trimArguments\")\r\n\r\n\r\nmodule.exports = Future\r\n\r\nFuture.debug = false // switch this to true if you want ids and long stack traces\r\n\r\nvar curId = 0         // for ids\\\r\nfunction Future(value) {\r\n\tif(arguments.length > 0) {\r\n\t\tvar f = new Future()\r\n        f.return(value)\r\n        return f\r\n\t} else {\r\n        this.isResolved = false\r\n        this.queue = []\r\n        if(Future.debug) {\r\n            curId++\r\n            this.id = curId\r\n        }\r\n    }\r\n}\r\n\r\n// static methods\r\n\r\n// has one parameter: either a bunch of futures, or a single array of futures\r\n// returns a promise that resolves when one of them errors, or when all of them succeeds\r\nFuture.all = function() {\r\n    if(arguments[0] instanceof Array) {\r\n        var futures = arguments[0]\r\n    } else {\r\n        var futures = trimArgs(arguments)\r\n    }\r\n\r\n    var f = new Future()\r\n    var results = []\r\n\r\n    if(futures.length > 0) {\r\n        var current = futures[0]\r\n        futures.forEach(function(future, index) {\r\n            current = current.then(function(v) {\r\n                results[index] = v\r\n                return futures[index+1]\r\n            })\r\n        })\r\n\r\n        //if\r\n        current.catch(function(e) {\r\n            f.throw(e)\r\n        })\r\n        // else\r\n        current.then(function() {\r\n            f.return(results)\r\n        })\r\n\r\n\r\n    } else {\r\n        f.return(results)\r\n    }\r\n\r\n    return f\r\n}\r\n\r\n// either used like futureWrap(function(){ ... })(arg1,arg2,etc) or\r\n//  futureWrap(object, 'methodName')(arg1,arg2,etc)\r\nFuture.wrap = function() {\r\n    // function\r\n    if(arguments.length === 1) {\r\n        var fn = arguments[0]\r\n        var object = undefined\r\n\r\n\r\n    // object, function\r\n    } else {\r\n        var object = arguments[0]\r\n        var fn = object[arguments[1]]\r\n    }\r\n\r\n    return function() {\r\n        var args = Array.prototype.slice.call(arguments)\r\n        var future = new Future\r\n        args.push(future.resolver())\r\n        var me = this\r\n        if(object) me = object\r\n        fn.apply(me, args)\r\n        return future\r\n    }\r\n}\r\n\r\n\r\n// default\r\nvar unhandledErrorHandler = function(e) {\r\n    setTimeout(function() {\r\n        throw e\r\n    },0)\r\n}\r\n\r\n// setup unhandled error handler\r\n// unhandled errors happen when done is called, and  then an exception is thrown from the future\r\nFuture.error = function(handler) {\r\n    unhandledErrorHandler = handler\r\n}\r\n\r\n// instance methods\r\n\r\n// returns a value for the future (can only be executed once)\r\n// if there are callbacks waiting on this value, they are run in the next tick\r\n    // (ie they aren't run immediately, allowing the current thread of execution to complete)\r\nFuture.prototype.return = function(v) {\r\n    resolve(this, 'return', v)\r\n}\r\nFuture.prototype.throw = function(e) {\r\n    resolve(this, 'error', e)\r\n}\r\n\r\nfunction setNext(that, future) {\r\n    if(future !== undefined && !isLikeAFuture(future) )\r\n        throw Error(\"Value returned from then or catch *not* a Future: \"+future)\r\n\r\n    resolve(that, 'next', future)\r\n}\r\n\r\nfunction wait(that, cb) {\r\n    if(that.isResolved) {\r\n        executeCallbacks(that, [cb])\r\n    } else {\r\n        that.queue.push(cb)\r\n    }\r\n}\r\n\r\n// duck typing to determine if something is or isn't a future\r\nfunction isLikeAFuture(x) {\r\n    return x.isResolved !== undefined && x.queue !== undefined && x.then !== undefined\r\n}\r\n\r\nfunction waitOnResult(f, result, cb) {\r\n    wait(result, function() {\r\n        if(this.hasError) {\r\n            f.throw(this.error)\r\n        } else if(this.hasNext) {\r\n            waitOnResult(f, this.next, cb)\r\n        } else {\r\n            try {\r\n                setNext(f, cb(this.result))\r\n            } catch(e) {\r\n                f.throw(e)\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\n\r\n// cb takes one parameter - the value returned\r\n// cb can return a Future, in which case the result of that Future is passed to next-in-chain\r\nFuture.prototype.then = function(cb) {\r\n    var f = new Future\r\n    wait(this, function() {\r\n        if(this.hasError)\r\n            f.throw(this.error)\r\n        else if(this.hasNext)\r\n            waitOnResult(f, this.next, cb)\r\n        else {\r\n            try {\r\n                setNext(f, cb(this.result))\r\n            } catch(e) {\r\n                f.throw(e)\r\n            }\r\n        }\r\n    })\r\n    return f\r\n}\r\n// cb takes one parameter - the error caught\r\n// cb can return a Future, in which case the result of that Future is passed to next-in-chain\r\nFuture.prototype.catch = function(cb) {\r\n    var f = new Future\r\n    wait(this, function() {\r\n        if(this.hasError) {\r\n            try {\r\n                setNext(f, cb(this.error))\r\n            } catch(e) {\r\n                f.throw(e)\r\n            }\r\n        } else if(this.hasNext) {\r\n            this.next.then(function(v) {\r\n                f.return(v)\r\n            }).catch(function(e) {\r\n                setNext(f, cb(e))\r\n            })\r\n        } else {\r\n            f.return(this.result)\r\n        }\r\n    })\r\n    return f\r\n}\r\n// cb takes no parameters\r\n// callback's return value is ignored, but thrown exceptions propogate normally\r\nFuture.prototype.finally = function(cb) {\r\n    var f = new Future\r\n    wait(this, function() {\r\n        try {\r\n            if(this.hasNext) {\r\n                this.next.then(function(v) {\r\n                    var x = cb()\r\n                    f.return(v)\r\n                    return x\r\n                }).catch(function(e) {\r\n                    var x = cb()\r\n                    f.throw(e)\r\n                    return x\r\n                }).done()\r\n            } else if(this.hasError) {\r\n                Future(true).then(function() {\r\n                    return cb()\r\n                }).then(function() {\r\n                    f.throw(this.error)\r\n                }).catch(function(e) {\r\n                    f.throw(e)\r\n                }).done()\r\n\r\n            } else  {\r\n                Future(true).then(function() {\r\n                    return cb()\r\n                }).then(function() {\r\n                    f.return(this.result)\r\n                }).catch(function(e) {\r\n                    f.throw(e)\r\n                }).done()\r\n            }\r\n        } catch(e) {\r\n            f.throw(e)\r\n        }\r\n    })\r\n    return f\r\n}\r\n\r\n// all unused futures should end with this (e.g. most then-chains)\r\n// detatches the future so any propogated exception is thrown (so the exception isn't silently lost)\r\nFuture.prototype.done = function() {\r\n    wait(this, function() {\r\n        if(this.hasError) {\r\n            unhandledErrorHandler(this.error)\r\n        } else if(this.hasNext) {\r\n            this.next.catch(function(e) {\r\n                unhandledErrorHandler(e)\r\n            })\r\n        }\r\n    })\r\n}\r\n\r\n\r\n\r\nFuture.prototype.resolver = function() {\r\n    var me = this\r\n\r\n    return function(e,v) {\r\n        if(e) { // error argument\r\n            me.throw(e)\r\n        } else {\r\n            me.return(v)\r\n        }\r\n    }\r\n}\r\n\r\nFuture.prototype.resolved = function() {\r\n    return this.isResolved\r\n}\r\n\r\n\r\nfunction resolve(that, type, value) {\r\n    if(that.isResolved)\r\n        throw Error(\"Future resolved more than once! Resolution: \"+value)\r\n\r\n    that.isResolved = true\r\n    that.hasError = type === 'error'\r\n    that.hasNext = type === 'next' && value !== undefined\r\n\r\n    if(that.hasError)\r\n        that.error = value\r\n    else if(that.hasNext)\r\n        that.next = value\r\n    else\r\n        that.result = value\r\n\r\n    executeCallbacks(that, that.queue)\r\n}\r\n\r\nfunction executeCallbacks(that, callbacks) {\r\n    if(callbacks.length > 0) {\r\n        setTimeout(function() {\r\n            callbacks.forEach(function(cb) {\r\n                cb.apply(that)\r\n            })\r\n        },0)\r\n    }\r\n}\r\n"],"sourceRoot":"webpack-module://"}